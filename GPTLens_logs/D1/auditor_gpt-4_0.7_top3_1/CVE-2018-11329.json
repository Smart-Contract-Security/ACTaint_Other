[
    {
        "function_name": "collectDrugs",
        "code": "function collectDrugs(address ref) public{ require(initialized); if(referrals[msg.sender]==0 && referrals[msg.sender]!=msg.sender){ referrals[msg.sender]=ref; } uint256 drugsUsed=getMyDrugs(); uint256 newKilo=SafeMath.div(drugsUsed,DRUGS_TO_PRODUCE_1KILO); Kilos[msg.sender]=SafeMath.add(Kilos[msg.sender],newKilo); claimedDrugs[msg.sender]=0; lastCollect[msg.sender]=now; claimedDrugs[referrals[msg.sender]]=SafeMath.add(claimedDrugs[referrals[msg.sender]],SafeMath.div(drugsUsed,5)); marketDrugs=SafeMath.add(marketDrugs,SafeMath.div(drugsUsed,10)); }",
        "vulnerability": "Reentrancy",
        "reason": "This function is vulnerable to reentrancy attack. The function makes an external call to the contract address (msg.sender) before it resolves its state changes. An attacker can create a fallback function in a contract to recursively call this function, draining the contract of ETH before it has a chance to set 'claimedDrugs[msg.sender]' to 0, resulting in the attacker being able to claim more drugs than they should be able to.",
        "file_name": "CVE-2018-11329.sol"
    },
    {
        "function_name": "sellDrugs",
        "code": "function sellDrugs() public{ require(initialized); uint256 hasDrugs=getMyDrugs(); uint256 drugValue=calculateDrugSell(hasDrugs); uint256 fee=devFee(drugValue); claimedDrugs[msg.sender]=0; lastCollect[msg.sender]=now; marketDrugs=SafeMath.add(marketDrugs,hasDrugs); ceoAddress.transfer(fee); msg.sender.transfer(SafeMath.sub(drugValue,fee)); }",
        "vulnerability": "Reentrancy",
        "reason": "This function is also vulnerable to a reentrancy attack, as it also makes an external call to the contract address (msg.sender) before its state changes have been resolved. A fallback function could cause this function to be recursively called, allowing for the attacker to drain the contract of more ETH than they should be able to.",
        "file_name": "CVE-2018-11329.sol"
    },
    {
        "function_name": "buyDrugs",
        "code": "function buyDrugs() public payable{ require(initialized); uint256 drugsBought=calculateDrugBuy(msg.value,SafeMath.sub(this.balance,msg.value)); drugsBought=SafeMath.sub(drugsBought,devFee(drugsBought)); ceoAddress.transfer(devFee(msg.value)); claimedDrugs[msg.sender]=SafeMath.add(claimedDrugs[msg.sender],drugsBought); }",
        "vulnerability": "Integer Division",
        "reason": "The 'calculateDrugBuy' function can return a value that is not an integer, but the 'drugsBought' variable is declared as an uint256, which can only hold integer values. This can cause the actual amount of drugs bought to be less than expected, leading to a loss for users. In addition, the function also has a reentrancy vulnerability because it makes an external call (ceoAddress.transfer) before it resolves its state changes.",
        "file_name": "CVE-2018-11329.sol"
    }
]