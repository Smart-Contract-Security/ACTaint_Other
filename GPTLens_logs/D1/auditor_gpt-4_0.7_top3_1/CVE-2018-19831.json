[
    {
        "function_name": "transfer",
        "code": "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; }",
        "vulnerability": "Missing input validation",
        "reason": "The function does not properly validate the input. A user can send tokens to address 0, effectively burning them. This is a major issue because once tokens are sent to address 0, they cannot be retrieved.",
        "file_name": "CVE-2018-19831.sol"
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }",
        "vulnerability": "Race Condition (Front-Running)",
        "reason": "The function does not properly protect against race conditions. A user can call approve multiple times in a row and can potentially spend more tokens than they should be able to. This can be exploited by bots that monitor the blockchain for such transactions and are able to place transactions in the same block.",
        "file_name": "CVE-2018-19831.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() onlyOwner public { uint256 etherBalance = this.balance; owner.transfer(etherBalance); }",
        "vulnerability": "Unchecked send",
        "reason": "The function does not properly handle the possibility of a failed send. If the send fails for any reason, the contract's state will not be reverted, potentially leading to lost funds. This is a major issue because it can lead to the loss of ether that is supposed to be withdrawn.",
        "file_name": "CVE-2018-19831.sol"
    }
]