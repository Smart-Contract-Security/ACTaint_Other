[
    {
        "function_name": "releaseTokensTo",
        "code": "function releaseTokensTo(address buyer) internal returns(bool) { if( msg.value > 0 ) takeEther(buyer); giveToken(buyer); return true; }",
        "vulnerability": "Reentrancy Attack",
        "reason": "The function 'releaseTokensTo' is vulnerable to a reentrancy attack. This is because it calls an external contract 'giveToken' while the state of the current contract has not been fully updated. An attacker could make a recursive call back into 'releaseTokensTo' before 'giveToken' has finished executing.",
        "file_name": "CVE-2020-17753.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw(address to, uint256 value) public onlyTokenSaleOwner { to.transfer(value); }",
        "vulnerability": "Unchecked Return Values",
        "reason": "The 'withdraw' function sends Ether using 'transfer' without checking its return value. If the 'transfer' call fails due to the receiving contract throwing an exception, the current contract will not be aware of the failure. This could lead to a loss of funds.",
        "file_name": "CVE-2020-17753.sol"
    },
    {
        "function_name": "buyImplementation",
        "code": "function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) private returns (bool) { bytes32 hash = sha256(\"Eidoo icoengine authorization\", address(0), buyerAddress, buyerId, maxAmount); address signer = ecrecover(hash, v, r, s); if (!isKycSigner[signer]) { revert(); } else { uint256 totalPayed = alreadyPayed[buyerId].add(msg.value); require(totalPayed <= maxAmount); alreadyPayed[buyerId] = totalPayed; emit KycVerified(signer, buyerAddress, buyerId, maxAmount); return releaseTokensTo(buyerAddress); } }",
        "vulnerability": "Integer Overflow and Underflow",
        "reason": "The 'buyImplementation' function is vulnerable to integer overflow and underflow. This is because it performs arithmetic operations without checking if the results overflow or underflow. An attacker could exploit this vulnerability to manipulate the states of the contract.",
        "file_name": "CVE-2020-17753.sol"
    }
]