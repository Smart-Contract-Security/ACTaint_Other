[
    {
        "function_name": "distr",
        "vulnerability": "Unreachable code",
        "criticism": "The reasoning is correct. The 'return' statement in the function causes the subsequent code to be unreachable, which could lead to an indefinite distribution of tokens. However, the severity is moderate because it depends on the function's usage and the profitability is low because an external attacker cannot profit from it.",
        "correctness": 9,
        "severity": 5,
        "profitability": 0,
        "reason": "After the 'return' statement, the code will not be executed, so 'if (totalDistributed >= totalSupply) { distributionFinished = true; }' will never be executed. This could lead to an indefinite distribution of tokens even totalDistributed is greater than totalSupply.",
        "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "file_name": "CVE-2019-15078.sol"
    },
    {
        "function_name": "approve",
        "vulnerability": "Approval Race Condition (ERC20)",
        "criticism": "The reasoning is partially correct. The function does have a potential race condition, but it's not as severe as stated. The function checks if the allowance is non-zero, the new value must be zero (and vice versa), which mitigates the risk. The profitability is also low because an external attacker cannot directly profit from this vulnerability.",
        "correctness": 6,
        "severity": 3,
        "profitability": 1,
        "reason": "This function allows for potential double-spending due to the race condition in ERC20 standard. An attacker could be approved to spend tokens, spend them, then have the approval amount increased and spend the new approval, essentially spending more than originally approved.",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",
        "file_name": "CVE-2019-15078.sol"
    },
    {
        "function_name": "getTokens",
        "vulnerability": "Re-entrancy",
        "criticism": "The reasoning is incorrect. The function does not call external contracts, and emitting an event does not allow for re-entrancy attacks. The value change after calling 'distr' could lead to inconsistencies, but it's not a re-entrancy vulnerability. The severity and profitability are both low.",
        "correctness": 2,
        "severity": 2,
        "profitability": 0,
        "reason": "The function allows for potential re-entrancy attacks. While it doesn't directly call external contracts, it does call the 'distr' function which emits an event. If the event listener were malicious, it could attempt re-entrancy. Also, the value is changed after calling distr which can lead to inconsistencies.",
        "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
        "file_name": "CVE-2019-15078.sol"
    }
]