[
    {
        "function_name": "buyDrugs",
        "vulnerability": "Integer Division",
        "criticism": "The reasoning is partially correct. The 'calculateDrugBuy' function could indeed return a non-integer value, which could lead to a loss for users. However, the reentrancy vulnerability claim is incorrect. The function does not make any external calls before all its state changes are resolved. The 'claimedDrugs[msg.sender]=SafeMath.add(claimedDrugs[msg.sender],drugsBought)' statement is executed before any potential external calls could be made. Therefore, a reentrancy attack is not possible in this case.",
        "correctness": 5,
        "severity": 4,
        "profitability": 3,
        "reason": "The 'calculateDrugBuy' function can return a value that is not an integer, but the 'drugsBought' variable is declared as an uint256, which can only hold integer values. This can cause the actual amount of drugs bought to be less than expected, leading to a loss for users. In addition, the function also has a reentrancy vulnerability because it makes an external call (ceoAddress.transfer) before it resolves its state changes.",
        "code": "function buyDrugs() public payable{ require(initialized); uint256 drugsBought=calculateDrugBuy(msg.value,SafeMath.sub(this.balance,msg.value)); drugsBought=SafeMath.sub(drugsBought,devFee(drugsBought)); ceoAddress.transfer(devFee(msg.value)); claimedDrugs[msg.sender]=SafeMath.add(claimedDrugs[msg.sender],drugsBought); }",
        "file_name": "CVE-2018-11329.sol",
        "final_score": 4.25
    },
    {
        "function_name": "collectDrugs",
        "vulnerability": "Reentrancy",
        "criticism": "The reasoning is incorrect. The function does not make any external calls before all its state changes are resolved. The 'claimedDrugs[msg.sender]=0' statement is executed before any potential external calls could be made. Therefore, a reentrancy attack is not possible in this case. The correctness, severity, and profitability are all low.",
        "correctness": 2,
        "severity": 1,
        "profitability": 1,
        "reason": "This function is vulnerable to reentrancy attack. The function makes an external call to the contract address (msg.sender) before it resolves its state changes. An attacker can create a fallback function in a contract to recursively call this function, draining the contract of ETH before it has a chance to set 'claimedDrugs[msg.sender]' to 0, resulting in the attacker being able to claim more drugs than they should be able to.",
        "code": "function collectDrugs(address ref) public{ require(initialized); if(referrals[msg.sender]==0 && referrals[msg.sender]!=msg.sender){ referrals[msg.sender]=ref; } uint256 drugsUsed=getMyDrugs(); uint256 newKilo=SafeMath.div(drugsUsed,DRUGS_TO_PRODUCE_1KILO); Kilos[msg.sender]=SafeMath.add(Kilos[msg.sender],newKilo); claimedDrugs[msg.sender]=0; lastCollect[msg.sender]=now; claimedDrugs[referrals[msg.sender]]=SafeMath.add(claimedDrugs[referrals[msg.sender]],SafeMath.div(drugsUsed,5)); marketDrugs=SafeMath.add(marketDrugs,SafeMath.div(drugsUsed,10)); }",
        "file_name": "CVE-2018-11329.sol",
        "final_score": 1.5
    },
    {
        "function_name": "sellDrugs",
        "vulnerability": "Reentrancy",
        "criticism": "The reasoning is incorrect. The function does not make any external calls before all its state changes are resolved. The 'claimedDrugs[msg.sender]=0' statement is executed before any potential external calls could be made. Therefore, a reentrancy attack is not possible in this case. The correctness, severity, and profitability are all low.",
        "correctness": 2,
        "severity": 1,
        "profitability": 1,
        "reason": "This function is also vulnerable to a reentrancy attack, as it also makes an external call to the contract address (msg.sender) before its state changes have been resolved. A fallback function could cause this function to be recursively called, allowing for the attacker to drain the contract of more ETH than they should be able to.",
        "code": "function sellDrugs() public{ require(initialized); uint256 hasDrugs=getMyDrugs(); uint256 drugValue=calculateDrugSell(hasDrugs); uint256 fee=devFee(drugValue); claimedDrugs[msg.sender]=0; lastCollect[msg.sender]=now; marketDrugs=SafeMath.add(marketDrugs,hasDrugs); ceoAddress.transfer(fee); msg.sender.transfer(SafeMath.sub(drugValue,fee)); }",
        "file_name": "CVE-2018-11329.sol",
        "final_score": 1.5
    }
]