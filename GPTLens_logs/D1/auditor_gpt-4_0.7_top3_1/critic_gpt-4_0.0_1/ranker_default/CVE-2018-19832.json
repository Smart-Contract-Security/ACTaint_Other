[
    {
        "function_name": "withdraw",
        "vulnerability": "Arbitrary Withdrawal by Owner",
        "criticism": "The reasoning is correct. The 'withdraw' function allows the contract owner to withdraw all the contract's balance at any time. This could lead to a loss of funds for users if the owner decides to act maliciously. The severity is high because it could lead to a total loss of funds. The profitability is low because only the owner can exploit this vulnerability.",
        "correctness": 9,
        "severity": 9,
        "profitability": 1,
        "reason": "The 'withdraw' function allows the contract owner to withdraw all the contract's balance at any time. This could result in loss of funds for users if the owner decides to act maliciously.",
        "code": "function withdraw() onlyOwner public { uint256 etherBalance = address(this).balance; owner.transfer(etherBalance); }",
        "file_name": "CVE-2018-19832.sol",
        "final_score": 7.0
    },
    {
        "function_name": "distr",
        "vulnerability": "Unreachable Code",
        "criticism": "The reasoning is correct. The 'return true' statement is followed by more code, making the code after the return statement unreachable. In this case, the check for 'totalDistributed >= totalSupply' will never be reached, and 'distributionFinished' will never be set to true. The severity is moderate because it could lead to incorrect contract behavior. The profitability is low because it does not provide an opportunity for an attacker to profit.",
        "correctness": 9,
        "severity": 5,
        "profitability": 0,
        "reason": "The 'return true' statement is followed by more code. This makes the code after the return statement unreachable and hence useless. In this case, the check for 'totalDistributed >= totalSupply' will never be reached, and 'distributionFinished' will never be set to true.",
        "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "file_name": "CVE-2018-19832.sol",
        "final_score": 5.75
    },
    {
        "function_name": "approve",
        "vulnerability": "Race Condition / Front Running",
        "criticism": "The reasoning is partially correct. The 'approve' function does have a known race condition vulnerability in the ERC20 token standard. However, in this specific implementation, the function checks if the new value is non-zero and the current allowance is non-zero, in which case it returns false. This mitigates the risk of front-running. Therefore, the severity and profitability are low.",
        "correctness": 5,
        "severity": 2,
        "profitability": 2,
        "reason": "The 'approve' function of the ERC20 token standard is known to be vulnerable to a race condition. If a user wants to change the allowance of a spender that is not zero, they have to set the allowance to zero first in a separate transaction. If they don't, the spender can front run the transaction that sets the new allowance, spending the original allowance and the new allowance.",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",
        "file_name": "CVE-2018-19832.sol",
        "final_score": 3.5
    }
]