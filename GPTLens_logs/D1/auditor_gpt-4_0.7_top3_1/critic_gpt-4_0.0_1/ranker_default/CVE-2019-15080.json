[
    {
        "function_name": "owned",
        "vulnerability": "Initialization vulnerability",
        "criticism": "The reasoning is correct. The owner is not set in the constructor but in a public 'owned' function. This means that anyone can call this function and become the owner of the contract before the actual owner gets a chance to call it. This could result in a complete loss of control over the contract. The severity is high because it can lead to a complete loss of control over the contract. The profitability is also high because an attacker can gain control over the contract.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The owner is not set in the constructor but in a public 'owned' function. This means that anyone can call this function and become the owner of the contract before the actual owner gets a chance to call it. This could result in a complete loss of control over the contract.",
        "code": "function owned() public { owner = msg.sender; }",
        "file_name": "CVE-2019-15080.sol",
        "final_score": 9.0
    },
    {
        "function_name": "mintTokens",
        "vulnerability": "Inflation vulnerability",
        "criticism": "The reasoning is correct. The 'mintTokens' function allows the owner to increase the total supply of tokens at will. This can lead to inflation and devaluation of tokens, affecting all token holders. However, this is not inherently a vulnerability, but rather a design decision that might be questionable. The severity is moderate because it is based on the owner's intention. The profitability is low because an external attacker cannot profit from it.",
        "correctness": 7,
        "severity": 4,
        "profitability": 0,
        "reason": "The 'mintTokens' function allows the owner to increase the total supply of tokens at will. This can lead to inflation and devaluation of tokens, affecting all token holders.",
        "code": "function mintTokens(uint256 _mintedAmount) public onlyOwner { balanceOf[owner] = balanceOf[owner].add(_mintedAmount); totalSupply = totalSupply.add(_mintedAmount); Transfer(0, owner, _mintedAmount); }",
        "file_name": "CVE-2019-15080.sol",
        "final_score": 4.5
    },
    {
        "function_name": "transfer",
        "vulnerability": "Front Running",
        "criticism": "The reasoning is incorrect. The function does check for the transaction order implicitly by checking the balance of the sender and the receiver. A malicious miner or an attacker cannot intercept the transaction and replace '_to' address with his own address because the transaction is signed by the sender. The severity is low because it does not cause severe exploitation and an external attacker cannot profit from this vulnerability.",
        "correctness": 2,
        "severity": 1,
        "profitability": 0,
        "reason": "Front running is possible because the function doesn't check for the transaction order. A malicious miner or an attacker can intercept the transaction and replace '_to' address with his own address.",
        "code": "function transfer(address _to, uint256 _value) public returns (bool) { require(!isblacklistedAccount[msg.sender]); require(!isblacklistedAccount[_to]); require(balanceOf[msg.sender] > 0); require(balanceOf[msg.sender] >= _value); require(_to != address(0)); require(_value > 0); require(balanceOf[_to] .add(_value) >= balanceOf[_to]); require(_to != msg.sender); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); Transfer(msg.sender, _to, _value); return true; }",
        "file_name": "CVE-2019-15080.sol",
        "final_score": 1.25
    }
]