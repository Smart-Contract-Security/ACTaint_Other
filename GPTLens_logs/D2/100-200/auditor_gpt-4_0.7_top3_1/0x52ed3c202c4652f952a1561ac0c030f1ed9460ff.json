[
    {
        "function_name": "kill",
        "code": "function kill() onlyowner { if (msg.sender == owner) suicide(owner); }",
        "vulnerability": "Use of deprecated function",
        "reason": "The use of 'suicide' is deprecated and should be replaced with 'selfdestruct' which is introduced in newer versions of Solidity. The function 'suicide' can lead to unexpected behavior or errors in newer Solidity environments.",
        "file_name": "0x52ed3c202c4652f952a1561ac0c030f1ed9460ff.sol"
    },
    {
        "function_name": "addSignature",
        "code": "function addSignature(uint id) { address member = msg.sender; if (documentsCount < id) throw; Document d = documentsIds[id]; uint count = d.signsCount; bool signed = false; if (count != 0) { for (uint i = 0; i < count; i++) { if (d.signs[i].member == member) { signed = true; break; } } } if (!signed) { d.signs[count] = Sign({ member: member, date: now }); documentsIds[id].signsCount = count + 1; DocumentSigned(id, member); } }",
        "vulnerability": "Unbounded loop",
        "reason": "The function iterates through all the signatures in a document to check if the sender has already signed it. This can result in high gas costs or even transaction failures due to out of gas exceptions if the number of signatures is very high. An attacker can exploit this by repeatedly adding new signatures to increase the gas cost of this function call.",
        "file_name": "0x52ed3c202c4652f952a1561ac0c030f1ed9460ff.sol"
    },
    {
        "function_name": "registerDocument",
        "code": "function registerDocument(string hash, string link, string data) { address creator = msg.sender; uint id = documentsCount + 1; documentsIds[id] = Document({ hash: hash, link: link, data: data, creator: creator, date: now, signsCount: 0 }); documentsCount = id; DocumentRegistered(id, hash); }",
        "vulnerability": "Integer overflow",
        "reason": "The documentsCount is incremented without checking for overflows. An attacker can potentially overflow the documentsCount by calling the registerDocument function repeatedly which can lead to overwriting existing documents if the count rolls over.",
        "file_name": "0x52ed3c202c4652f952a1561ac0c030f1ed9460ff.sol"
    }
]