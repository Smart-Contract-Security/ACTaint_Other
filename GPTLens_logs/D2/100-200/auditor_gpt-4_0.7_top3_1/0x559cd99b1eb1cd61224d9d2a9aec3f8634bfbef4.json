[
    {
        "function_name": "ActiveAdmin",
        "code": "function ActiveAdmin () public { owner = 0x3653A2205971AD524Ea31746D917430469D3ca23; }",
        "vulnerability": "Arbitrary Ownership Takeover",
        "reason": "The function ActiveAdmin allows a hardcoded address to take over the ownership of the contract without any checks or restrictions. This can be called by anyone, not just the current owner, leading to a situation where the contract's control could be seized by an unintended party.",
        "file_name": "0x559cd99b1eb1cd61224d9d2a9aec3f8634bfbef4.sol"
    },
    {
        "function_name": "executeLottery",
        "code": "function executeLottery() { if (lastIndex > SetPlayers) { uint randomNumber = uint(block.blockhash(block.number-1))%lastTicketNumber + 1; randomNumber = randomNumber; address winner; bool hasWon; for (uint8 i = 0; i < lastIndex; i++) { address player = players[i]; for (uint j = 0; j < ticketsMap[player].length; j++) { uint256 start = ticketsMap[player][j].startTicket; uint256 end = ticketsMap[player][j].endTicket; if (randomNumber >= start && randomNumber < end) { winner = player; hasWon = true; break; } } if(hasWon) break; } require(winner!=address(0) && hasWon); for (uint8 k = 0; k < lastIndex; k++) { delete ticketsMap[players[k]]; delete contributions[players[k]]; } lastIndex = 0; lastTicketNumber = 0; uint balance = this.balance; if (!owner.send(balance/devFeePercent)) throw; if (!winner.send(balance - balance/devFeePercent)) throw; newWinner(winner, randomNumber); } }",
        "vulnerability": "Predictable Randomness",
        "reason": "The executeLottery function uses block.blockhash of the previous block as a source of randomness. This can be manipulated by miners (since they have control over blockhash), or predicted by observing the blockchain, leading to potential exploitation where an attacker could increase their chances of winning.",
        "file_name": "0x559cd99b1eb1cd61224d9d2a9aec3f8634bfbef4.sol"
    },
    {
        "function_name": "executeLottery",
        "code": "function executeLottery() { if (lastIndex > SetPlayers) { uint randomNumber = uint(block.blockhash(block.number-1))%lastTicketNumber + 1; randomNumber = randomNumber; address winner; bool hasWon; for (uint8 i = 0; i < lastIndex; i++) { address player = players[i]; for (uint j = 0; j < ticketsMap[player].length; j++) { uint256 start = ticketsMap[player][j].startTicket; uint256 end = ticketsMap[player][j].endTicket; if (randomNumber >= start && randomNumber < end) { winner = player; hasWon = true; break; } } if(hasWon) break; } require(winner!=address(0) && hasWon); for (uint8 k = 0; k < lastIndex; k++) { delete ticketsMap[players[k]]; delete contributions[players[k]]; } lastIndex = 0; lastTicketNumber = 0; uint balance = this.balance; if (!owner.send(balance/devFeePercent)) throw; if (!winner.send(balance - balance/devFeePercent)) throw; newWinner(winner, randomNumber); } }",
        "vulnerability": "DoS with Throw",
        "reason": "The use of 'throw' in the executeLottery function for handling failed transfers is outdated and consumes all gas available to the transaction. This can lead to a denial of service attack if an attacker can cause the transfer to fail (e.g., by making the recipient a contract that always reverts), thus blocking the lottery execution.",
        "file_name": "0x559cd99b1eb1cd61224d9d2a9aec3f8634bfbef4.sol"
    }
]