[
    {
        "function_name": "distr",
        "vulnerability": "Unreachable code",
        "criticism": "The reasoning is accurate in identifying unreachable code after the return statement in the 'distr' function. This indeed prevents the 'distributionFinished' flag from being set, which is a significant logic flaw. The severity is high because it affects the functionality of the distribution process, potentially leading to an infinite distribution loop. However, the profitability for an attacker is low as this flaw does not directly result in a gain for an attacker, but rather a malfunction of the contract.",
        "correctness": 9,
        "severity": 7,
        "profitability": 1,
        "reason": "In the 'distr' function, the code to check if 'totalDistributed' is greater than or equal to 'totalSupply' and potentially setting 'distributionFinished' to true is unreachable because it comes after a 'return' statement. This means the distribution process might never be marked as finished even if the total distributed amount equals or exceeds the total supply.",
        "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "file_name": "0x2be511409c976bdcd141642969ece04cd1171403.sol"
    },
    {
        "function_name": "getTokens",
        "vulnerability": "Reentrancy",
        "criticism": "The reasoning provided is incorrect. The 'getTokens' function does not have a reentrancy vulnerability as described. The function does not make any external calls to untrusted contracts before updating the state (blacklist status), which is the typical condition for reentrancy. The 'distr' function is internal and controlled, assuming no reentrancy in 'distr' itself. Therefore, the severity and profitability are both low because the described attack scenario is not feasible.",
        "correctness": 2,
        "severity": 1,
        "profitability": 0,
        "reason": "The 'getTokens' function sends tokens using the 'distr' function and then modifies the 'blacklist' status of the sender. If an attacker can make a reentrant call to 'getTokens' within the same transaction, they might be able to receive more tokens than intended because the 'blacklist' update happens after the tokens are distributed. This could lead to unexpected distribution and depletion of tokens.",
        "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
        "file_name": "0x2be511409c976bdcd141642969ece04cd1171403.sol"
    },
    {
        "function_name": "approve",
        "vulnerability": "Approval race condition",
        "criticism": "The reasoning is partially correct about the potential for a race condition in the 'approve' function. However, the condition described (allowance must be zero or the new value must be zero) actually mitigates the typical race condition known as 'approve/transferFrom' attack by requiring any non-zero approvals to reset to zero first. This reduces the likelihood of a race condition being exploited. Therefore, the severity is moderate, but the profitability is low as exploiting such a condition requires specific circumstances and timing.",
        "correctness": 6,
        "severity": 4,
        "profitability": 2,
        "reason": "The 'approve' function allows changing the allowance only if the current allowance for a spender is zero or the new value to set is zero. This condition can lead to a race condition where the spender could potentially use the old allowance and the new one in quick succession, possibly leading to double spending issues if the spender's transactions are crafted cleverly.",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",
        "file_name": "0x2be511409c976bdcd141642969ece04cd1171403.sol"
    }
]