[
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr onlyWhitelist public { require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; if (msg.value < minReq){ toGive = value.sub(value); } distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Reentrancy",
        "reason": "The function getTokens() is vulnerable to reentrancy attacks because it calls distr() which transfers tokens to an external address (investor), and then performs further state updates after this call. An attacker can create a fallback function on their address to call getTokens() again when receiving tokens, leading to multiple withdrawals before the state (such as totalDistributed or blacklist) is updated.",
        "file_name": "0x5aef06ec39e98c05201ee1e54b653c372ecb9cf3.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() onlyOwner public { uint256 etherBalance = this.balance; owner.transfer(etherBalance); }",
        "vulnerability": "Unprotected Ether Withdrawal",
        "reason": "The withdraw function directly transfers the contract's balance to the owner without any checks or conditions apart from the onlyOwner modifier. If there are any vulnerabilities or bugs in other parts of the contract that allow an attacker to escalate privileges to owner or if the owner account is compromised, an attacker can drain all Ether stored in this contract.",
        "file_name": "0x5aef06ec39e98c05201ee1e54b653c372ecb9cf3.sol"
    },
    {
        "function_name": "distr",
        "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); Distr(_to, _amount); Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Gas Limit and Loops",
        "reason": "The distr function is called within loops in multiple other functions like airdrop, distribution, and distributeAmounts. Each call to distr includes state changes and event emissions which consume gas. If the loop iterates over a large array, it may consume all the gas provided to the transaction causing it to fail. This can lead to denial of service especially if used in critical functions that manage token distribution.",
        "file_name": "0x5aef06ec39e98c05201ee1e54b653c372ecb9cf3.sol"
    }
]