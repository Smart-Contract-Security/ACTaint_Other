[
    {
        "function_name": "withdraw",
        "code": "function withdraw(address recipient, uint256 balance) public onlyOwner { recipient.transfer(balance); }",
        "vulnerability": "reentrancy",
        "reason": "The 'withdraw' function directly transfers Ether to a recipient address without any checks for reentrancy attacks. An attacker can exploit this by creating a fallback function in the recipient contract that calls back into this contract, leading to multiple withdrawals.",
        "file_name": "0x66d58f0a2a44742688843ceb8c0fa8d8567e3c54.sol"
    },
    {
        "function_name": "makeWager",
        "code": "function makeWager() payable public { if (msg.value == 0 || msg.value > maxWagerWei) throw; if (wagers[msg.sender].active) { throw; } wagers[msg.sender] = Wager({ sender: msg.sender, wagerWei: msg.value, creationBlockNumber: block.number, active: true, }); }",
        "vulnerability": "denial of service",
        "reason": "The 'makeWager' function throws an exception if the sender already has an active wager or the sent value is zero or exceeds the maxWagerWei, which can be used by an attacker to lock funds by continuously sending transactions that meet these conditions, preventing legitimate users from making wagers.",
        "file_name": "0x66d58f0a2a44742688843ceb8c0fa8d8567e3c54.sol"
    },
    {
        "function_name": "getRand",
        "code": "function getRand(uint blockNumber, uint max) constant internal returns(uint) { return(uint(sha3(block.blockhash(blockNumber))) % max); }",
        "vulnerability": "predictable RNG",
        "reason": "The 'getRand' function uses the blockhash of a past block to generate a random number. Since blockhashes are accessible to all participants in the network, an attacker can predict the outcome of the random number generation if they can determine the block number used.",
        "file_name": "0x66d58f0a2a44742688843ceb8c0fa8d8567e3c54.sol"
    }
]