[
    {
        "function_name": "distr",
        "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); balances[_to] = balances[_to].add(_amount); Distr(_to, _amount); Transfer(address(0), _to, _amount); return true; }",
        "vulnerability": "Unchecked Distribution Limit",
        "reason": "The 'distr' function does not check if the '_amount' being distributed plus the 'totalDistributed' exceeds the 'totalSupply'. This could lead to overflowing 'totalDistributed' and creating tokens out of thin air, which violates the token conservation law and can severely impact the token's economy.",
        "file_name": "0x78af01b310a23d25009bdfb95ef06e9a5584fb80.sol"
    },
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr public { uint256 tokens = 0; require( msg.value >= MIN_CONTRIBUTION ); require( msg.value > 0 ); tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (tokens > 0) { distr(investor, tokens); } if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Reentrancy",
        "reason": "The 'getTokens' function is vulnerable to reentrancy attacks because it calls 'distr' which triggers external calls via events before updating the 'distributionFinished' state. An attacker can recursively call 'getTokens' in the callback of these events to drain funds or acquire more tokens than intended.",
        "file_name": "0x78af01b310a23d25009bdfb95ef06e9a5584fb80.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() onlyOwner public { address myAddress = this; uint256 etherBalance = myAddress.balance; owner.transfer(etherBalance); }",
        "vulnerability": "Unprotected Ether Withdrawal",
        "reason": "The 'withdraw' function transfers all Ether in the contract to the owner without any checks or limitations. This function should have security checks or limits to prevent potential abuse where the owner can continuously drain Ether sent to the contract by users.",
        "file_name": "0x78af01b310a23d25009bdfb95ef06e9a5584fb80.sol"
    }
]