[
    {
        "function_name": "addMember",
        "code": "function addMember( address who ) auth() { if( is_member[who] ) { revert(); } is_member[who] = true; MemberAdded(who); _members_remaining--; if( _members_remaining == 0 ) { updateAuthority( address(0x0), DSAuthModes.Owner ); } }",
        "vulnerability": "Authority Zeroing",
        "reason": "In the 'addMember' function, once all members have been added (i.e., _members_remaining reaches 0), the authority is updated to the zero address using 'updateAuthority( address(0x0), DSAuthModes.Owner )'. This effectively disables any further permissions checks controlled by the authority mechanism, making the contract permissions open or broken. This could allow unauthorized access or control over contract functions that rely on the authority for access control.",
        "file_name": "0x7bb0b08587b8a6b8945e09f1baca426558b0f06a.sol"
    },
    {
        "function_name": "trigger",
        "code": "function trigger( uint action_id ) { var a = actions[action_id]; if( a.confirmations < _required ) { revert(); } if( block.timestamp > a.expiration ) { revert(); } if( a.triggered ) { revert(); } if( this.balance < a.value ) { revert(); } a.triggered = true; exec( a.target, a.calldata, a.value ); actions[action_id] = a; emit Triggered(action_id); }",
        "vulnerability": "Reentrancy",
        "reason": "The 'trigger' function executes external calls via 'exec(a.target, a.calldata, a.value)'. However, the state updates such as 'a.triggered = true' and updating the 'actions' mapping occur after this external call. This could be exploited by a malicious contract at 'a.target' to re-enter the 'trigger' function and potentially manipulate actions or trigger multiple unauthorized actions before the state is updated to reflect the first action's execution. This can lead to unexpected behaviors and losses.",
        "file_name": "0x7bb0b08587b8a6b8945e09f1baca426558b0f06a.sol"
    },
    {
        "function_name": "propose",
        "code": "function propose( address target, bytes calldata, uint value ) returns (uint action_id) { action memory a; a.target = target; a.calldata = calldata; a.value = value; a.expiration = block.timestamp + _expiration; _last_action_id++; actions[_last_action_id] = a; emit Proposed(_last_action_id, calldata); return _last_action_id; }",
        "vulnerability": "Unbounded Array Growth",
        "reason": "The 'propose' function allows adding new actions to the 'actions' mapping without any limitations, where '_last_action_id' is incremented for each new proposal. This can lead to unbounded growth in the storage used by the 'actions' mapping. An attacker could repeatedly call this function to cause the contract to consume more and more gas, leading potentially to denial of service or making it prohibitively expensive to interact with the contract due to high gas costs associated with the large data structure.",
        "file_name": "0x7bb0b08587b8a6b8945e09f1baca426558b0f06a.sol"
    }
]