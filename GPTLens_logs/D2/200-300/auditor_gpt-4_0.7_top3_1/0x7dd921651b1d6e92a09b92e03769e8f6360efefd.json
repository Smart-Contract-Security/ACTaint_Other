[
    {
        "function_name": "TeamTokensAllocation",
        "code": "function TeamTokensAllocation () public { owner = msg.sender; uint256 TeamTokens = 1000000000e8; distr(owner, TeamTokens); }",
        "vulnerability": "Unauthorized access",
        "reason": "The function TeamTokensAllocation allows any user to call it and reassign the contract's owner while distributing tokens to themselves. This can lead to unauthorized control of the contract and token theft.",
        "file_name": "0x7dd921651b1d6e92a09b92e03769e8f6360efefd.sol"
    },
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr public { uint256 tokens = 0; require( msg.value >= minContribution ); require( msg.value > 0 ); tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (tokens > 0) { distr(investor, tokens); } if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Reentrancy",
        "reason": "The function getTokens is vulnerable to reentrancy attacks because it calls an external contract (via distr) before updating its state (totalDistributed and distributionFinished). An attacker could recursively call getTokens in the callback of the distr function to drain ETH from the contract.",
        "file_name": "0x7dd921651b1d6e92a09b92e03769e8f6360efefd.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() onlyOwner public { address myAddress = this; uint256 etherBalance = myAddress.balance; owner.transfer(etherBalance); }",
        "vulnerability": "Unchecked send",
        "reason": "The withdraw function directly transfers all contract balance to the owner without checking the success of the transfer. If the transfer fails, the contract will not be aware, potentially leading to lost funds or denial of service if the contract logic depends on successful withdrawal.",
        "file_name": "0x7dd921651b1d6e92a09b92e03769e8f6360efefd.sol"
    }
]