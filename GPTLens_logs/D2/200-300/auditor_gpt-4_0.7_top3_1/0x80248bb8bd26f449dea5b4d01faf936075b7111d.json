[
    {
        "function_name": "transferViaSignature",
        "code": "function transferViaSignature ( address from, address to, uint256 value, uint256 fee, uint256 deadline, uint256 sigId, bytes sig, sigStandard sigStd ) external returns (bool) { requireSignature( keccak256(address(this), from, to, value, fee, deadline, sigId), from, deadline, sigId, sig, sigStd, sigDestination.transfer ); internalDoubleTransfer(from, to, value, msg.sender, fee); return true; }",
        "vulnerability": "Reentrancy",
        "reason": "The function 'transferViaSignature' allows for external calls via 'internalDoubleTransfer' which includes a transfer of tokens. This can be exploited through a reentrancy attack if the recipient is a contract that calls back into any functions of this contract that alter state.",
        "file_name": "0x80248bb8bd26f449dea5b4d01faf936075b7111d.sol"
    },
    {
        "function_name": "approveAndCallViaSignature",
        "code": "function approveAndCallViaSignature ( address from, address spender, uint256 value, bytes extraData, uint256 fee, uint256 deadline, uint256 sigId, bytes sig, sigStandard sigStd ) external returns (bool) { requireSignature( keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId), from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall ); allowance[from][spender] = value; emit Approval(from, spender, value); tokenRecipient(spender).receiveApproval(from, value, this, extraData); internalTransfer(from, msg.sender, fee); return true; }",
        "vulnerability": "Reentrancy",
        "reason": "This function is vulnerable to reentrancy attacks because it calls an external contract (tokenRecipient) after setting allowances but before transferring fees. A malicious contract could use the 'receiveApproval' call to re-enter and modify the state in a way that could exploit the contract.",
        "file_name": "0x80248bb8bd26f449dea5b4d01faf936075b7111d.sol"
    },
    {
        "function_name": "lastMint",
        "code": "function lastMint () external { require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0); uint256 remaining = totalSupply * 40 / 60; uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals); if (fractionalPart <= remaining) remaining -= fractionalPart; balanceOf[tokenDistributor] += remaining; emit Transfer(0x0, tokenDistributor, remaining); totalSupply += remaining; tokenDistributor = 0x0; }",
        "vulnerability": "Arithmetic Overflow",
        "reason": "The calculation of 'remaining' and 'fractionalPart' in 'lastMint' function lacks proper validation and can lead to integer overflow if the totalSupply is exceptionally high. This can allow manipulation of supply and balances in unexpected ways, potentially leading to loss of funds or unintended token minting.",
        "file_name": "0x80248bb8bd26f449dea5b4d01faf936075b7111d.sol"
    }
]