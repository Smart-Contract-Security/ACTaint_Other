[
    {
        "function_name": "openLottery",
        "code": "function openLottery(uint8 _viewId) public returns(uint8,uint8) { uint8 viewId = _viewId; require(viewId < 7); uint256 currentTerm = CLotteries.length - 1; CLottery storage clottery = CLotteries[currentTerm]; if (currentGene == 0 && clottery.openBlock > 0 && clottery.isReward == false) { OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, clottery.openBlock, clottery.totalAmount); return (clottery.luckyGenes[viewId],1); } if (lastBlockNumber == block.number) { OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, clottery.openBlock, clottery.totalAmount); return (clottery.luckyGenes[viewId],2); } if (currentGene == 0 && clottery.isReward == true) { CLottery memory _clottery; _clottery.luckyGenes = [0,0,0,0,0,0,0]; _clottery.totalAmount = uint256(0); _clottery.isReward = false; _clottery.openBlock = uint256(0); currentTerm = CLotteries.push(_clottery) - 1; } if (this._isCarousal(currentTerm)) { revert(); } uint8 luckyNum = 0; uint256 bonusBalance = dogCore.getAvailableBlance(); if (currentGene == 6) { if (bonusBalance <= SpoolAmount) { OpenLottery(viewId, clottery.luckyGenes[viewId], currentTerm, 0, 0); return (clottery.luckyGenes[viewId],3); } luckyNum = random(8); CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum; OpenLottery(currentGene, luckyNum, currentTerm, block.number, bonusBalance); currentGene = 0; CLotteries[currentTerm].openBlock = block.number; CLotteries[currentTerm].totalAmount = bonusBalance; lastBlockNumber = block.number; } else { luckyNum = random(12); CLotteries[currentTerm].luckyGenes[currentGene] = luckyNum; OpenLottery(currentGene, luckyNum, currentTerm, 0, 0); currentGene ++; lastBlockNumber = block.number; } return (luckyNum,0); }",
        "vulnerability": "Block Timestamp Dependency",
        "reason": "The function 'random' used within 'openLottery' relies on 'block.timestamp' and 'block.difficulty' for generating randomness which can be manipulated by miners to some extent, influencing the outcome of the lottery.",
        "file_name": "0x8b9d642d1e455119778a5aaca416a216feec163d.sol"
    },
    {
        "function_name": "distributeLottery",
        "code": "function distributeLottery() public returns (uint8) { (luckyGenes, totalAmount, openBlock, isReward, currentTerm) = lotteryCore.getCLottery(); require(openBlock > 0 && openBlock < (block.number-duration)); require(totalAmount >= lotteryCore.SpoolAmount()); if (isReward == true) { DistributeLottery(flotteries[currentTerm].reward, currentTerm); return 1; } uint256 legalAmount = totalAmount - lotteryCore.SpoolAmount(); uint256 totalDistribute = 0; uint8[7] memory lR; uint8 ratio; if (lotteryCore._isCarousal(currentTerm) ) { lR = carousalParam; ratio = carousalRatio; } else { lR = lotteryParam; ratio = lotteryRatio; } for (uint8 i = 0; i < 7; i++) { address[] memory owners; uint256[] memory dogs; (dogs, owners) = _getLuckyList(currentTerm, i); if (owners.length > 0) { uint256 reward = (legalAmount * ratio * lR[i])/(10000 * owners.length); totalDistribute += reward * owners.length; dogCore.sendMoney(dogCore.cfoAddress(),reward * owners.length/10); for (uint j = 0; j < owners.length; j++) { address gen0Add; if (i == 0) { dogCore.sendMoney(owners[j],reward*95*9/1000); gen0Add = _getGen0Address(dogs[j]); if(gen0Add != address(0)){ dogCore.sendMoney(gen0Add,reward*5/100); } } else if (i == 1) { dogCore.sendMoney(owners[j],reward*97*9/1000); gen0Add = _getGen0Address(dogs[j]); if(gen0Add != address(0)){ dogCore.sendMoney(gen0Add,reward*3/100); } } else if (i == 2) { dogCore.sendMoney(owners[j],reward*98*9/1000); gen0Add = _getGen0Address(dogs[j]); if(gen0Add != address(0)){ dogCore.sendMoney(gen0Add,reward*2/100); } } else { dogCore.sendMoney(owners[j],reward*9/10); } } flotteries[currentTerm].reward.push(reward); } else { flotteries[currentTerm].reward.push(0); } } if (flotteries[currentTerm].owners0.length == 0) { lotteryCore.toSPool((dogCore.getAvailableBlance() - lotteryCore.SpoolAmount())/20); lotteryCore.rewardLottery(true); } else { lotteryCore.rewardLottery(false); } DistributeLottery(flotteries[currentTerm].reward, currentTerm); return 0; }",
        "vulnerability": "Integer Division",
        "reason": "The reward calculation uses integer division which may lead to losses due to truncation, especially when dealing with distributions among multiple participants, potentially causing disputes or unintended financial discrepancies.",
        "file_name": "0x8b9d642d1e455119778a5aaca416a216feec163d.sol"
    },
    {
        "function_name": "setLotteryDuration",
        "code": "function setLotteryDuration(uint256 durationBlocks) public { require(msg.sender == dogCore.ceoAddress()); require(durationBlocks > 140); require(durationBlocks < block.number); duration = durationBlocks; }",
        "vulnerability": "Improper Access Control",
        "reason": "The function 'setLotteryDuration' is only protected by a check for the CEO's address. However, it still allows the duration to be set to a value less than the current block number, which can lead to logical errors in the lottery duration calculation and can be exploited if the CEO's address is compromised.",
        "file_name": "0x8b9d642d1e455119778a5aaca416a216feec163d.sol"
    }
]