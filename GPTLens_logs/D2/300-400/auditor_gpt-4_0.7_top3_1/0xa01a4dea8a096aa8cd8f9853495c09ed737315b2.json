[
    {
        "function_name": "transferOwnership",
        "code": "function transferOwnership(address _newOwner) onlyOwner public { owner = _newOwner; }",
        "vulnerability": "Ownership takeover",
        "reason": "This function allows the current owner to transfer ownership to any other address, including potentially malicious ones, without any checks besides ownership. If a malicious user gains control over the owner's account, they can transfer ownership to themselves and take full control of the contract.",
        "file_name": "0xa01a4dea8a096aa8cd8f9853495c09ed737315b2.sol"
    },
    {
        "function_name": "() payable",
        "code": "function () payable public validGasPrice { require(msg.sender != address(0)); require(msg.value != 0); require(msg.value>=0.1 ether); require(isContributionAllowed()); contributors[msg.sender] = contributors[msg.sender].add(msg.value); weiRaised = weiRaised.add(msg.value); uint256 numberOfTokens = 0; if (isPreTokenSaleActive()) { numberOfTokens = msg.value/presalesTokenPriceInWei; numberOfTokens = numberOfTokens * (1e18); require((numberOfTokens + numberOfTokensAllocated) <= presalesCap); tokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens); numberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens); forwardFunds(); emit ContributionReceived(msg.sender, msg.value, numberOfTokens); } else if (isTokenSaleActive()) { numberOfTokens = msg.value/publicsalesTokenPriceInWei; numberOfTokens = numberOfTokens * (1e18); require((numberOfTokens + numberOfTokensAllocated) <= (presalesCap + publicsalesCap)); tokensAllocated[msg.sender] = tokensAllocated[msg.sender].add(numberOfTokens); numberOfTokensAllocated = numberOfTokensAllocated.add(numberOfTokens); forwardFunds(); emit ContributionReceived(msg.sender, msg.value, numberOfTokens); } checkifCapHasReached(); }",
        "vulnerability": "Integer overflow",
        "reason": "In the computation of 'numberOfTokens', there's potential for an integer overflow when multiplying 'msg.value / presalesTokenPriceInWei' by 1e18. If this overflow occurs, it can lead to incorrect calculations of tokens to be allocated, which can be exploited to obtain more tokens than owed or disrupt the contract's token tracking.",
        "file_name": "0xa01a4dea8a096aa8cd8f9853495c09ed737315b2.sol"
    },
    {
        "function_name": "refundContribution",
        "code": "function refundContribution(address _contributor, uint256 _weiAmount) public onlyOwner returns (bool) { require(_contributor != 0); if (!_contributor.send(_weiAmount)) { return false; } else { contributors[_contributor] = 0; return true; } }",
        "vulnerability": "Reentrancy",
        "reason": "The function 'refundContribution' sends Ether to an address before setting the contributor's balance to 0. This can be exploited by a malicious contract that re-enters 'refundContribution' during the .send() call, potentially allowing the attacker to withdraw more Ether than they contributed initially.",
        "file_name": "0xa01a4dea8a096aa8cd8f9853495c09ed737315b2.sol"
    }
]