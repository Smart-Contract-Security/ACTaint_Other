[
    {
        "function_name": "distr",
        "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Unreachable code",
        "reason": "In the 'distr' function, the statement 'if (totalDistributed >= totalSupply) { distributionFinished = true; }' will never be executed because it is placed after the 'return' statement. This could lead to unintended distribution behavior where the distribution does not stop even when the total distributed tokens exceed or meet the total supply.",
        "file_name": "0xa8dbd8beab9a664fc5a74920bd47411e56966997.sol"
    },
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
        "vulnerability": "Reentrancy",
        "reason": "The function 'getTokens' allows for potential reentrancy attacks. It calls an external function 'distr' which updates several state variables and emits events, and only then it modifies the 'blacklist' and 'value'. An attacker can exploit reentrancy by making a recursive call back to 'getTokens' within the same transaction, possibly leading to unexpected behaviors such as incorrect token distribution or manipulation of the 'value' variable.",
        "file_name": "0xa8dbd8beab9a664fc5a74920bd47411e56966997.sol"
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",
        "vulnerability": "ERC20 approve race condition",
        "reason": "The 'approve' function has a known race condition vulnerability where if the '_value' is not zero and there is already an allowed amount for the '_spender', the function will simply return false without updating the allowance. This can lead to issues where users may think they have successfully changed an allowance, which could affect secure transaction logic dependent on the approval mechanism.",
        "file_name": "0xa8dbd8beab9a664fc5a74920bd47411e56966997.sol"
    }
]