[
    {
        "function_name": "chooseWinner",
        "code": "function chooseWinner() private {\n    address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n    address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n    uint seed3 = block.difficulty;\n    bytes32 randHash = keccak256(seed1, seed2, seed3);\n    uint winningNumber = uint(randHash) % totalTickets;\n    address winningAddress = contestants[winningNumber].addr;\n    RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n    raffleId++;\n    nextTicket = 0;\n    winningAddress.transfer(prize);\n    feeAddress.transfer(fee);\n}",
        "vulnerability": "Predictable Randomness",
        "reason": "The random number generation in 'chooseWinner' is predictable as it relies on block.coinbase, msg.sender, and block.difficulty, which can be influenced or anticipated by miners or users calling the function, allowing manipulation of the random result to increase the chance of a specific outcome.",
        "file_name": "0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol"
    },
    {
        "function_name": "getRefund",
        "code": "function getRefund() public {\n    uint refund = 0;\n    for (uint i = 0; i < totalTickets; i++) {\n        if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n            refund += pricePerTicket;\n            contestants[i] = Contestant(address(0), 0);\n            gaps.push(i);\n            TicketRefund(raffleId, msg.sender, i);\n        }\n    }\n    if (refund > 0) {\n        msg.sender.transfer(refund);\n    }\n}",
        "vulnerability": "Reentrancy",
        "reason": "The 'getRefund' function is vulnerable to a reentrancy attack because it calls an external contract (msg.sender.transfer) while the contract's state is not fully finalized (the 'contestants' mapping is updated prior to the transfer). An attacker can recursively call 'getRefund' to drain more funds than they are entitled to.",
        "file_name": "0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol"
    },
    {
        "function_name": "buyTickets",
        "code": "function buyTickets() payable public {\n    if (paused) {\n        msg.sender.transfer(msg.value);\n        return;\n    }\n    uint moneySent = msg.value;\n    while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n        uint currTicket = 0;\n        if (gaps.length > 0) {\n            currTicket = gaps[gaps.length-1];\n            gaps.length--;\n        } else {\n            currTicket = nextTicket++;\n        }\n        contestants[currTicket] = Contestant(msg.sender, raffleId);\n        TicketPurchase(raffleId, msg.sender, currTicket);\n        moneySent -= pricePerTicket;\n    }\n    if (nextTicket == totalTickets) {\n        chooseWinner();\n    }\n    if (moneySent > 0) {\n        msg.sender.transfer(moneySent);\n    }\n}",
        "vulnerability": "Denial of Service",
        "reason": "In 'buyTickets', if the 'gaps' array has insufficient elements when a gap is accessed (gaps[gaps.length-1]), it can lead to an array underflow, where gaps.length becomes negative. This can halt ticket purchasing by causing transactions to fail, leading to a denial of service situation.",
        "file_name": "0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol"
    }
]