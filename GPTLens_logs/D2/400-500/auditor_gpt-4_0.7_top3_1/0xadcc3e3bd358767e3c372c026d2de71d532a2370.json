[
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr onlyWhitelist public {\n    if (value > totalRemaining) {\n        value = totalRemaining;\n    }\n    require(value <= totalRemaining);\n    address investor = msg.sender;\n    uint256 toGive = value;\n    distr(investor, toGive);\n    if (toGive > 0) {\n        blacklist[investor] = true;\n    }\n    if (totalDistributed >= totalSupply) {\n        distributionFinished = true;\n    }\n    value = value.div(1000).mul(999);\n}",
        "vulnerability": "Reentrancy",
        "reason": "The 'getTokens' function is vulnerable to reentrancy attacks because it calls 'distr' which triggers external state changes (like transfer) before updating the caller's state. This allows the attacker to re-enter the function multiple times in one transaction before their state (blacklist) is updated, potentially allowing them to withdraw more tokens than intended.",
        "file_name": "0xadcc3e3bd358767e3c372c026d2de71d532a2370.sol"
    },
    {
        "function_name": "burn",
        "code": "function burn(uint256 _value) onlyOwner public {\n    require(_value <= balances[msg.sender]);\n    address burner = msg.sender;\n    balances[burner] = balances[burner].sub(_value);\n    totalSupply = totalSupply.sub(_value);\n    totalDistributed = totalDistributed.sub(_value);\n    Burn(burner, _value);\n}",
        "vulnerability": "Integer Underflow",
        "reason": "In the 'burn' function, although there is a check to ensure that the value to be burned is not greater than the sender's balance, there is no check to ensure that the totalDistributed does not underflow when subtracted by _value. This could lead to an underflow, setting totalDistributed to a very high value if the burn amount is greater than totalDistributed.",
        "file_name": "0xadcc3e3bd358767e3c372c026d2de71d532a2370.sol"
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) {\n    if (_value != 0 && allowed[msg.sender][_spender] != 0) {\n        return false;\n    }\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n}",
        "vulnerability": "ERC20 Approve/Allowance Race Condition",
        "reason": "The 'approve' function is susceptible to a race condition where, if a user first approves an allowance and then decides to change it, a malicious spender could potentially submit a transaction to use the initial allowance just after it's approved but before it's changed, exploiting the time window where both are valid.",
        "file_name": "0xadcc3e3bd358767e3c372c026d2de71d532a2370.sol"
    }
]