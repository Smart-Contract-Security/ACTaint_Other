[
    {
        "function_name": "fallback function",
        "code": "function () saleIsOn private payable { if(msg.value == 0 && msg.sender == last.depositor) { require(gasleft() >= 220000, \"We require more gas!\"); require(last.blockNumber + 45 < block.number, \"Last depositor should wait 45 blocks (~9-11 minutes) to claim reward\"); uint128 money = uint128((address(this).balance)); if(money >= last.expect){ last.depositor.transfer(last.expect); } else { last.depositor.transfer(money); } delete last; } else if(msg.value > 0){ require(gasleft() >= 220000, \"We require more gas!\"); require(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT); queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100))); last.depositor = msg.sender; last.expect += msg.value*LAST_DEPOSIT_PERCENT/100; last.blockNumber = block.number; txnCount += 1; if(txnCount > 200) { MIN_DEPOSIT = 0.05 ether; } else if(txnCount > 150) { MIN_DEPOSIT = 0.04 ether; } else if(txnCount > 100) { MIN_DEPOSIT = 0.03 ether; }else if(txnCount > 50) { MIN_DEPOSIT = 0.02 ether; }else { MIN_DEPOSIT = 0.01 ether; } uint promo = msg.value*PROMO_PERCENT/100; uint128 contractBalance = uint128((address(this).balance)); if(contractBalance >= promo){ PROMO.transfer(promo); } else { PROMO.transfer(contractBalance); } pay(); } }",
        "vulnerability": "Reentrancy on ether transfer",
        "reason": "The fallback function transfers ether to both PROMO and the last.depositor based on certain conditions without using the checks-effects-interactions pattern. This can allow an attacker to re-enter the contract multiple times in a single transaction if the external contract called is malicious and fallback function is invoked recursively. Reentrancy could lead to unexpected behavior like draining contract funds.",
        "file_name": "0xb6d3dad9dde4d21cae7e245c88a75fbf2efa18c4.sol"
    },
    {
        "function_name": "pay",
        "code": "function pay() private { uint128 moneyCoefficient = uint128((address(this).balance)/last.expect); uint128 money = uint128((address(this).balance)-last.expect); if(moneyCoefficient < 1) { return; } for(uint i=0; i<queue.length; i++){ uint idx = currentReceiverIndex + i; Deposit storage dep = queue[idx]; if(money >= dep.expect){ dep.depositor.transfer(dep.expect); money -= dep.expect; delete queue[idx]; }else{ dep.depositor.transfer(money); dep.expect -= money; break; } if(gasleft() <= 50000) break; } currentReceiverIndex += i; }",
        "vulnerability": "Unbounded loop",
        "reason": "The 'pay' function iterates over 'queue' without setting a strict upper bound on the number of iterations. If 'queue' becomes large enough, the function could run out of gas, making it unable to process all items in 'queue'. This could lead to funds getting stuck in the contract because not all depositors are paid out.",
        "file_name": "0xb6d3dad9dde4d21cae7e245c88a75fbf2efa18c4.sol"
    },
    {
        "function_name": "fallback function",
        "code": "function () saleIsOn private payable { if(msg.value == 0 && msg.sender == last.depositor) { require(gasleft() >= 220000, \"We require more gas!\"); require(last.blockNumber + 45 < block.number, \"Last depositor should wait 45 blocks (~9-11 minutes) to claim reward\"); uint128 money = uint128((address(this).balance)); if(money >= last.expect){ last.depositor.transfer(last.expect); } else { last.depositor.transfer(money); } delete last; } else if(msg.value > 0){ require(gasleft() >= 220000, \"We require more gas!\"); require(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT); queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value*MULTIPLIER/100))); last.depositor = msg.sender; last.expect += msg.value*LAST_DEPOSIT_PERCENT/100; last.blockNumber = block.number; txnCount += 1; if(txnCount > 200) { MIN_DEPOSIT = 0.05 ether; } else if(txnCount > 150) { MIN_DEPOSIT = 0.04 ether; } else if(txnCount > 100) { MIN_DEPOSIT = 0.03 ether; }else if(txnCount > 50) { MIN_DEPOSIT = 0.02 ether; }else { MIN_DEPOSIT = 0.01 ether; } uint promo = msg.value*PROMO_PERCENT/100; uint128 contractBalance = uint128((address(this).balance)); if(contractBalance >= promo){ PROMO.transfer(promo); } else { PROMO.transfer(contractBalance); } pay(); } }",
        "vulnerability": "Dynamic gas requirements",
        "reason": "The fallback function requires a minimum of 220,000 gas to execute, which is dynamically checked using gasleft(). This can lead to situations where legitimate transactions are unable to proceed because they do not meet the gas requirement, potentially leading to denial of service if the gas price is high or if there are constraints on transaction gas limits.",
        "file_name": "0xb6d3dad9dde4d21cae7e245c88a75fbf2efa18c4.sol"
    }
]