[
    {
        "function_name": "chooseWinner",
        "code": "function chooseWinner() private {\n    bytes32 sha = sha3( block.timestamp, block.number, block.gaslimit, block.difficulty, msg.gas, msg.value, msg.sender, block.coinbase );\n    uint winningNumber = (uint(sha) % totalTickets) + 1;\n    address winningAddress = contestants[winningNumber].addr;\n    RaffleResult(\n        raffleId,\n        winningNumber,\n        winningAddress,\n        block.timestamp,\n        block.number,\n        block.gaslimit,\n        block.difficulty,\n        msg.gas,\n        msg.value,\n        msg.sender,\n        block.coinbase,\n        sha\n    );\n    raffleId++;\n    nextTicket = 1;\n    winningAddress.transfer(prize);\n    rakeAddress.transfer(rake);\n}",
        "vulnerability": "Predictable randomness",
        "reason": "The 'chooseWinner' function uses environmental variables such as block.timestamp, block.number, block.difficulty, and others to generate a random winner. However, these parameters can be influenced or predicted by miners, leading to a vulnerability where a miner could potentially manipulate the results to ensure they win the raffle.",
        "file_name": "0xb7177696646a98a70520c37740d4a7659362f5b3.sol"
    },
    {
        "function_name": "buyTickets",
        "code": "function buyTickets() payable public {\n    uint moneySent = msg.value;\n    while (moneySent >= pricePerTicket && nextTicket <= totalTickets) {\n        uint currTicket = 0;\n        if (gaps.length > 0) {\n            currTicket = gaps[gaps.length-1];\n            gaps.length--;\n        } else {\n            currTicket = nextTicket++;\n        }\n        contestants[currTicket] = Contestant(msg.sender, raffleId);\n        TicketPurchase(raffleId, msg.sender, currTicket);\n        moneySent -= pricePerTicket;\n    }\n    if (nextTicket > totalTickets) {\n        chooseWinner();\n    }\n    if (moneySent > 0) {\n        msg.sender.transfer(moneySent);\n    }\n}",
        "vulnerability": "DoS with unexpected revert",
        "reason": "The 'buyTickets' function includes a refund mechanism for surplus money sent by users. However, if the contract's balance is less than the 'moneySent' due to other contract interactions or fees, the 'msg.sender.transfer(moneySent)' call will fail, reverting the transaction. This can be exploited by a malicious user who intentionally sends more ether than expected to block others from buying tickets.",
        "file_name": "0xb7177696646a98a70520c37740d4a7659362f5b3.sol"
    },
    {
        "function_name": "getRefund",
        "code": "function getRefund() public {\n    uint refunds = 0;\n    for (uint i = 1; i <= totalTickets; i++) {\n        if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n            refunds++;\n            contestants[i] = Contestant(address(0), 0);\n            gaps.push(i);\n            TicketRefund(raffleId, msg.sender, i);\n        }\n    }\n    if (refunds > 0) {\n        msg.sender.transfer(refunds * pricePerTicket);\n    }\n}",
        "vulnerability": "Unchecked external call",
        "reason": "In the 'getRefund' function, the external call 'msg.sender.transfer(refunds * pricePerTicket)' is made to return funds. If the external call fails (e.g., if the caller is a contract that throws an error), the entire transaction is reverted. This can be used to lock funds in the contract by always causing the transfer to fail.",
        "file_name": "0xb7177696646a98a70520c37740d4a7659362f5b3.sol"
    }
]