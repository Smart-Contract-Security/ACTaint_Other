[
    {
        "function_name": "refund",
        "code": "function refund() private {\n    uint256 weiValue = this.balance;\n    if (weiValue == 0) throw;\n    uint256 weiRefunded;\n    weiRefunded = safeAdd(weiRefunded, weiValue);\n    refund();\n    if (!msg.sender.send(weiValue)) throw;\n}",
        "vulnerability": "Recursive Call",
        "reason": "The 'refund' function recursively calls itself without any termination condition, which leads to unbounded recursion causing the call stack to exceed its limit and eventually leading to a stack overflow exception. This can be exploited by an attacker to force the contract to consume all gas and halt its execution, potentially leading to denial of service.",
        "file_name": "0xb8d24ac55866236b2c7b8fb046ca110d488fba02.sol"
    },
    {
        "function_name": "claim_ico",
        "code": "function claim_ico(){\n    if (bought_tokens) return;\n    if (kill_switch) throw;\n    bought_tokens = true;\n    time_bought = now + 1 days;\n    token.proxyPayment.value(this.balance - ico)(address(this));\n    if(this.balance > max_eth_to_end) {\n        msg.sender.transfer(ico);\n    } else {\n        extra_time_bought = now + 1 days * 10;\n        if(this.balance < min_eth_to_end) throw;\n        else {\n            if (now > extra_time_bought) {\n                msg.sender.transfer(ico);\n            }\n        }\n    }\n}",
        "vulnerability": "Reentrancy",
        "reason": "The 'claim_ico' function transfers Ether with 'msg.sender.transfer(ico)' which can allow reentrant calls. This is risky because the state 'bought_tokens' is set to true before the transfer, but other state updates and logical checks occur after this transfer. If the caller is a malicious contract, it could call back into 'claim_ico' or other public functions of this contract in the same transaction, potentially leading to unexpected behavior such as draining contract funds or other state corruption.",
        "file_name": "0xb8d24ac55866236b2c7b8fb046ca110d488fba02.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw(){\n    if (!bought_tokens) {\n        uint256 eth_amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        msg.sender.transfer(eth_amount);\n    } else {\n        uint256 ZBR_amount = balances[msg.sender] * ZBR_per_eth;\n        balances[msg.sender] = 0;\n        uint256 fee = 0;\n        if (!checked_in[msg.sender]) {\n            fee = ZBR_amount / 100;\n            if(!token.transfer(developer_address, fee)) throw;\n        }\n        if(!token.transfer(msg.sender, ZBR_amount - fee)) throw;\n    }\n}",
        "vulnerability": "Unchecked Return Values",
        "reason": "The 'withdraw' function does not check the return value of 'msg.sender.transfer(eth_amount)' and 'token.transfer()' calls. This can lead to a situation where the transfer fails (due to a throw in the receiver contract, or the receiver running out of gas), but the contract state is still updated as if the transfer was successful. This may lead to a loss of funds or incorrect accounting of balances, allowing an attacker to repeatedly withdraw funds or tokens.",
        "file_name": "0xb8d24ac55866236b2c7b8fb046ca110d488fba02.sol"
    }
]