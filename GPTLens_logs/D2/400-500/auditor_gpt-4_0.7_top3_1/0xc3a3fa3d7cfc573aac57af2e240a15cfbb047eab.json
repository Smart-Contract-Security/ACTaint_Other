[
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }",
        "vulnerability": "Reentrancy",
        "reason": "The 'approve' function is susceptible to a reentrancy attack because it does not follow the Checks-Effects-Interactions pattern. The allowance is set after emitting the Approval event, which can be used as a reentrancy vector if the _spender is a contract that calls back into this contract.",
        "file_name": "0xc3a3fa3d7cfc573aac57af2e240a15cfbb047eab.sol"
    },
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr public { uint256 tokens = 0; require( msg.value >= minContribution ); require( msg.value > 0 ); tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (tokens > 0) { distr(investor, tokens); } if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Integer Overflow",
        "reason": "In the 'getTokens' function, the calculation of 'tokens' can overflow if the product of 'tokensPerEth' and 'msg.value' is large enough. This overflow can result in an incorrect number of tokens being distributed, potentially resulting in financial loss or the unintended minting of additional tokens.",
        "file_name": "0xc3a3fa3d7cfc573aac57af2e240a15cfbb047eab.sol"
    },
    {
        "function_name": "transfer",
        "code": "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; }",
        "vulnerability": "Unchecked Return Value",
        "reason": "The 'transfer' function does not check the return value of 'sub' and 'add' methods from the SafeMath library. If these methods fail (though unlikely due to internal assert), the function would continue execution and not handle potential errors properly, leading to inconsistent state or token loss.",
        "file_name": "0xc3a3fa3d7cfc573aac57af2e240a15cfbb047eab.sol"
    }
]