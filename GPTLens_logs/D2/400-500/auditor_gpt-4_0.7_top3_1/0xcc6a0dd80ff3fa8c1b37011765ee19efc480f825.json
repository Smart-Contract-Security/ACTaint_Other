[
    {
        "function_name": "distr",
        "code": "function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); Distr(_to, _amount); Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Logic flaw",
        "reason": "The function distr has a logic flaw where the conditional check to set distributionFinished = true; will never be executed because it is placed after the return statement. This could result in continued distribution even after the total supply has been distributed, leading to unexpected token inflation.",
        "file_name": "0xcc6a0dd80ff3fa8c1b37011765ee19efc480f825.sol"
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }",
        "vulnerability": "Unexpected behavior in token allowance",
        "reason": "The approve function has a condition that prevents updating the allowance value when it is not zero unless the new value is also zero. This behavior deviates from the typical ERC20 standard, where you should be able to freely update the allowance. This might confuse users and interface developers, potentially leading to locked allowances where users cannot change them if not set to zero first.",
        "file_name": "0xcc6a0dd80ff3fa8c1b37011765ee19efc480f825.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw() onlyOwner public { uint256 etherBalance = this.balance; owner.transfer(etherBalance); }",
        "vulnerability": "Lack of checks",
        "reason": "The withdraw function sends all Ether in the contract to the owner without any checks or conditions beyond ownership. If the contract unexpectedly receives Ether (e.g., through selfdestruct from another contract), these funds can be withdrawn by the owner, which may not be an intended use of funds sent to the contract.",
        "file_name": "0xcc6a0dd80ff3fa8c1b37011765ee19efc480f825.sol"
    }
]