[
    {
        "function_name": "getTokens",
        "vulnerability": "Reentrancy",
        "criticism": "The reasoning provided is valid as the function 'getTokens' does indeed make an external call to 'distr' before updating the 'blacklist' and 'distributionFinished' flags. This could allow for reentrancy where an attacker re-enters the function during the external call, potentially leading to multiple distributions to the same investor. The severity is high due to the potential for token distribution manipulation, and profitability is moderate as an attacker could exploit this to receive more tokens than intended.",
        "correctness": 8,
        "severity": 7,
        "profitability": 5,
        "reason": "The 'getTokens' function is vulnerable to reentrancy attacks. It updates the 'blacklist' and 'distributionFinished' status after the call to 'distr', which is an external call. If the function is called again (re-entered) before these statuses are updated, it could potentially lead to incorrect distribution behavior or even multiple distributions to the same investor.",
        "code": "function getTokens() payable canDistr onlyWhitelist public {\n    if (value > totalRemaining) {\n        value = totalRemaining;\n    }\n    require(value <= totalRemaining);\n    address investor = msg.sender;\n    uint256 toGive = value;\n    distr(investor, toGive);\n    if (toGive > 0) {\n        blacklist[investor] = true;\n    }\n    if (totalDistributed >= totalSupply) {\n        distributionFinished = true;\n    }\n    value = value.div(100000).mul(99999);\n}",
        "file_name": "0xcca92f4e45f6cea3b1ce39c14ce3218f94a1f9fa.sol",
        "final_score": 7.0
    },
    {
        "function_name": "burn",
        "vulnerability": "Incorrect Balance Update",
        "criticism": "The reasoning is partially correct. The 'burn' function does check that '_value' is less than or equal to 'balances[msg.sender]' before proceeding with burning tokens. However, the criticism about not validating excess distribution is not entirely accurate as the function does not need to consider 'totalDistributed' for burning tokens from the owner's balance. The severity is low because the function primarily affects the token owner's balance and total supply correctly. Profitability is also low as there is no direct way for an attacker to exploit this for profit.",
        "correctness": 4,
        "severity": 2,
        "profitability": 1,
        "reason": "The 'burn' function reduces 'totalSupply' and 'totalDistributed' without validating that the '_value' to burn is actually available in excess of what has been distributed. This could lead to inconsistencies in totalSupply and totalDistributed calculations, potentially allowing for the burning of tokens that are considered as distributed.",
        "code": "function burn(uint256 _value) onlyOwner public {\n    require(_value <= balances[msg.sender]);\n    address burner = msg.sender;\n    balances[burner] = balances[burner].sub(_value);\n    totalSupply = totalSupply.sub(_value);\n    totalDistributed = totalDistributed.sub(_value);\n    emit Burn(burner, _value);\n}",
        "file_name": "0xcca92f4e45f6cea3b1ce39c14ce3218f94a1f9fa.sol",
        "final_score": 2.75
    },
    {
        "function_name": "transfer",
        "vulnerability": "Integer Overflow/Underflow",
        "criticism": "The reasoning is incorrect. The 'transfer' function uses the 'sub' function from a safe math library (indicated by the '.sub' method), which inherently checks for underflows. Therefore, there is no risk of underflow when '_amount' is zero as the subtraction operation is safe. The severity and profitability are both low because the function correctly handles the case of zero amounts, preventing any unintended behavior.",
        "correctness": 1,
        "severity": 0,
        "profitability": 0,
        "reason": "The 'transfer' function of the smart contract does not ensure that '_amount' is non-zero before subtracting it from 'balances[msg.sender]'. If '_amount' is zero and an underflow occurs, it could lead to arbitrary large balances, allowing users to transfer more tokens than they own.",
        "code": "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n    require(_to != address(0));\n    require(_amount <= balances[msg.sender]);\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Transfer(msg.sender, _to, _amount);\n    return true;\n}",
        "file_name": "0xcca92f4e45f6cea3b1ce39c14ce3218f94a1f9fa.sol",
        "final_score": 0.5
    }
]