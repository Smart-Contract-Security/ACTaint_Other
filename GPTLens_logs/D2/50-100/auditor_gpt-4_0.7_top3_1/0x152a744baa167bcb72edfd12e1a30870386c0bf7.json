[
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr public { uint256 tokens = 0; require( msg.value >= minContribution ); require( msg.value > 0 ); tokens = tokensPerEth.mul(msg.value) / 1 ether; address investor = msg.sender; if (tokens > 0) { distr(investor, tokens); } if (totalDistributed >= totalSupply) { distributionFinished = true; } }",
        "vulnerability": "Reentrancy",
        "reason": "The function 'getTokens' is vulnerable to reentrancy attacks. It calls 'distr' which updates the balances and totalDistributed, and then checks if totalDistributed >= totalSupply to potentially finish distribution. An attacker can recursively call 'getTokens' because there are no checks to prevent a function from being re-entered within the same transaction. This could lead to unexpected behavior or denial of service as the state may change in between calls.",
        "file_name": "0x152a744baa167bcb72edfd12e1a30870386c0bf7.sol"
    },
    {
        "function_name": "transfer",
        "code": "function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(msg.sender, _to, _amount); return true; }",
        "vulnerability": "Unchecked Return Value",
        "reason": "The function 'transfer' does not check the return value of the 'sub' and 'add' functions from the SafeMath library. Although SafeMath functions use assert for error handling, it's a best practice in Solidity to handle potential errors explicitly. Failing to do so can lead to unexpected behavior if the contract's state is not updated as intended.",
        "file_name": "0x152a744baa167bcb72edfd12e1a30870386c0bf7.sol"
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",
        "vulnerability": "Approval Race Condition",
        "reason": "The 'approve' function is susceptible to a race condition known as the 'approval race condition'. If a user wants to change the approval from one non-zero value to another, the condition `if (_value != 0 && allowed[msg.sender][_spender] != 0)` may lead to unexpected behavior. An attacker can exploit the race condition by making a transfer in between the calls to 'approve', leading to potential loss or theft of tokens.",
        "file_name": "0x152a744baa167bcb72edfd12e1a30870386c0bf7.sol"
    }
]