[
    {
        "function_name": "initiateWithFees",
        "code": "function initiateWithFees( bytes32 _swapID, address _spender, address _broker, uint256 _brokerFee, bytes32 _secretLock, uint256 _timelock, uint256 _value ) external onlyInvalidSwaps(_swapID) { CompatibleERC20(TOKEN_ADDRESS).transferFrom(msg.sender, address(this), _value); Swap memory swap = Swap({ timelock: _timelock, value: _value - _brokerFee, funder: msg.sender, spender: _spender, broker: _broker, brokerFee: _brokerFee, secretLock: _secretLock, secretKey: 0x0 }); swaps[_swapID] = swap; swapStates[_swapID] = States.OPEN; emit LogOpen(_swapID, _spender, _secretLock); }",
        "vulnerability": "Underflow risk",
        "reason": "The function 'initiateWithFees' calculates the value of the swap by subtracting the broker fee from the total value (_value - _brokerFee). However, there is no check ensuring that _value is greater than or equal to _brokerFee. As a result, this could lead to underflow where _value is less than _brokerFee, setting the swap value to an unexpectedly high number due to underflow, impacting the economics of the contract and potentially leading to loss of funds.",
        "file_name": "0x15c10c51d86a51021d0683b8359fb20a8ba40b45.sol"
    },
    {
        "function_name": "refund",
        "code": "function refund(bytes32 _swapID) external onlyOpenSwaps(_swapID) onlyExpirableSwaps(_swapID) { swapStates[_swapID] = States.EXPIRED; CompatibleERC20(TOKEN_ADDRESS).transfer(swaps[_swapID].funder, swaps[_swapID].value + swaps[_swapID].brokerFee); emit LogExpire(_swapID); }",
        "vulnerability": "Reentrancy risk",
        "reason": "The 'refund' function changes the state of the swap to EXPIRED and then calls an external contract (ERC20 token) to transfer funds. The state change should ideally happen after the external call to mitigate reentrancy attacks. In the current setup, if the ERC20 token contract called is malicious or has a fallback function that re-enters the refund function, it might lead to multiple refunds (withdrawal of more funds than intended) because the state is already set to EXPIRED before the funds transfer.",
        "file_name": "0x15c10c51d86a51021d0683b8359fb20a8ba40b45.sol"
    },
    {
        "function_name": "withdrawBrokerFees",
        "code": "function withdrawBrokerFees(uint256 _amount) external { require(_amount <= brokerFees[msg.sender]); brokerFees[msg.sender] -= _amount; CompatibleERC20(TOKEN_ADDRESS).transfer(msg.sender, _amount); }",
        "vulnerability": "Reentrancy risk",
        "reason": "The function 'withdrawBrokerFees' allows brokers to withdraw their accumulated fees. It reduces the broker's recorded fees before making an external call to transfer ERC20 tokens. This function is susceptible to reentrancy attacks if the ERC20 token contract is malicious or has a non-standard behavior, potentially allowing repeated withdrawals before the first transaction completes, thus draining more funds than the broker is entitled to.",
        "file_name": "0x15c10c51d86a51021d0683b8359fb20a8ba40b45.sol"
    }
]