[
    {
        "function_name": "distribute",
        "code": "function distribute() public returns (uint result) { bool isPartner = (owner == msg.sender); uint totalShare = 0; for (uint i = 0; i < partners.length; i++) { if (partners[i].from == msg.sender) { isPartner = true; } totalShare += partners[i].share; } require(isPartner, 'Only partner can distrubute bonus.'); uint bonus = getBonus(); if (totalShare > 0) { uint price = ((bonus / 10) * 6) / totalShare; if (price > 0) { for (uint j = 0; j < partners.length; j++) { uint share = partners[j].share * price; partners[j].from.transfer(share); if (partners[j].from == msg.sender) { result += share; } } } if (price > 2 * 1 finney) { delete partners; } } uint ownerShare = (bonus / 10) * 4; owner.transfer(ownerShare); if (owner == msg.sender) { result += ownerShare; } }",
        "vulnerability": "Denial of Service (DoS) via Gas Limit",
        "reason": "The loop iteration in `distribute` function that transfers Ether to multiple addresses can run out of gas if there are many partners in the `partners` array. This could potentially freeze the contract by making it unable to distribute funds as the transaction repeatedly fails due to gas limit constraints.",
        "file_name": "0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol"
    },
    {
        "function_name": "checkRoll",
        "code": "function checkRoll(address addr, Roll storage rollReq) private { uint totalWin = 0; if (block.number <= rollReq.blocknum + BET_EXPIRATION_BLOCKS) { for (uint x = 0; x < rollReq.rollCount; x++) { totalWin += doRoll(addr, rollReq.bet, rollReq.lines, rollReq.blocknum, pendingBetAmount + rollTimes + x); } } else { totalWin = rollReq.bet * rollReq.rollCount - 2300; } pendingBetAmount -= rollReq.bet * rollReq.rollCount; if (totalWin > 0) { if (address(this).balance > totalWin + 2300) { addr.transfer(totalWin); } else { partners.push(PartnerShare(addr, totalWin / 1 finney)); } } }",
        "vulnerability": "Unchecked External Call",
        "reason": "In the `checkRoll` function, the call to `addr.transfer(totalWin)` is not checked for its return value. This means if the transfer fails (e.g., the recipient contract throws an exception), the contract would not handle it, potentially leading to inconsistent state or logic errors.",
        "file_name": "0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol"
    },
    {
        "function_name": "roll",
        "code": "function roll(uint8 lines, uint8 count) public payable { require (rolls[msg.sender].length == 0, \"Can't roll mutiple times.\"); uint betValue = msg.value / count; require (betValue >= MIN_BET && betValue <= MAX_BET, \"Bet amount should be within range.\"); rolls[msg.sender].push(Roll(betValue, lines, count, block.number, address(0))); if (rollHead == address(0)) { rollHead = msg.sender; } else { rolls[rollTail][0].next = msg.sender; } rollTail = msg.sender; pendingBetAmount += msg.value; jackpotPool += msg.value * JACKPOT_PERCENT / 100; minipotPool += msg.value * MINIPOT_PERCENT / 100; emit RollBegin(msg.sender, betValue, lines, count); }",
        "vulnerability": "Reentrancy",
        "reason": "The `roll` function updates the state after transferring Ether, which is prone to reentrancy attack. An attacker could potentially re-enter the contract in the middle of its execution, especially since the state changes (`rollHead`, `rollTail`, and financial pools) are done after making these calls.",
        "file_name": "0x17d0582dee50a5401bb8f65ac29ec2da50c670ea.sol"
    }
]