[
    {
        "function_name": "distributeAmounts",
        "code": "function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public { require(addresses.length <= 255); require(addresses.length == amounts.length); for (uint8 i = 0; i < addresses.length; i++) { require(amounts[i] <= totalRemaining); distr(addresses[i], amounts[i]); if (totalDistributed >= totalSupply) { distributionFinished = true; } } }",
        "vulnerability": "Integer Overflow",
        "reason": "The function allows the distribution of tokens based on an array of addresses and amounts. However, the 'distr' function within this loop manipulates 'totalDistributed' and 'totalRemaining' without proper checks for overflow. If an attacker passes a very high value in 'amounts', it could lead to integer overflow, resulting in an incorrect calculation of 'totalDistributed' or 'totalRemaining', potentially allowing unlimited token minting.",
        "file_name": "0x1d6a8165fb01a3e792fc913da2b41da2aabfac9b.sol"
    },
    {
        "function_name": "withdrawForeignTokens",
        "code": "function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) { ForeignToken token = ForeignToken(_tokenContract); uint256 amount = token.balanceOf(address(this)); return token.transfer(owner, amount); }",
        "vulnerability": "Unchecked External Call",
        "reason": "The function 'withdrawForeignTokens' transfers all tokens of a foreign token to the owner. It uses an external call to 'token.transfer(owner, amount)' but does not check the return value. If the external call fails (e.g., due to the token contract not having the expected 'transfer' function), the function will still execute, potentially leading to a state where the contract believes tokens have been withdrawn, but they have not been actually moved.",
        "file_name": "0x1d6a8165fb01a3e792fc913da2b41da2aabfac9b.sol"
    },
    {
        "function_name": "getTokens",
        "code": "function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); }",
        "vulnerability": "Reentrancy",
        "reason": "The 'getTokens' function is vulnerable to reentrancy attacks. It calls 'distr', which sends tokens to the caller before marking them as blacklisted. An attacker can call 'getTokens' repeatedly in the same transaction before the blacklist check occurs, allowing them to withdraw more tokens than intended.",
        "file_name": "0x1d6a8165fb01a3e792fc913da2b41da2aabfac9b.sol"
    }
]