[
    {
        "function_name": "fallback function",
        "code": "function() payable public { if (msg.value == 0) { return; } require(msg.value >= MINIMUM_INVEST, 'Too small amount, minimum 0.001 ether'); investor storage user = investors[msg.sender]; if (user.id == 0) { user.id = addresses.length; addresses.push(msg.sender); addresses.length++; investorCount ++; address referrer = bytesToAddress(msg.data); if (investors[referrer].deposit > 0 && referrer != msg.sender) { user.referrer = referrer; } } user.deposit += msg.value; user.deposits += 1; user.date = now; emit Invest(msg.sender, msg.value); depositAmount += msg.value; owner.transfer(msg.value / 5); if (user.referrer > 0x0) { uint bonusAmount = (msg.value / 100) * INTEREST; user.referrer.transfer(bonusAmount); emit RefFee(user.referrer, bonusAmount); if (user.deposits == 1) { msg.sender.transfer(bonusAmount); emit Cashback(msg.sender, bonusAmount); } } }",
        "vulnerability": "Reentrancy on Ether transfer",
        "reason": "The fallback function transfers ether to the owner and potentially to a referrer or the sender themselves, using `transfer` which only forwards 2300 gas but can still be susceptible to reentrancy. If the referrer or the sender are contracts, they could have a fallback function that re-enters this contract, possibly leading to unexpected behaviors or draining of funds.",
        "file_name": "0x20b3d3f8a3e4f7b23382d844f2ca1d7026d69479.sol"
    },
    {
        "function_name": "payout",
        "code": "function payout(uint limit) public { require(now >= payoutDate + PAYOUT_CUMULATIVE_INTERVAL, 'too fast payout request'); uint investorsPayout; uint txs; uint amount; for (uint idx = addresses.length - 1; --idx >= 1;) { address addr = addresses[idx]; if (investors[addr].date + 24 hours > now) { continue; } amount = getInvestorUnPaidAmount(addr); investors[addr].date = now; if (address(this).balance < amount) { selfdestruct(owner); return; } addr.transfer(amount); investorsPayout += amount; if (++txs >= limit) { break; } } payoutDate = now; emit PayoutCumulative(investorsPayout, txs); }",
        "vulnerability": "Integer underflow and unchecked loop",
        "reason": "The loop in the `payout` function uses an unchecked `--idx` which can cause an integer underflow when `idx` becomes zero. This underflow can lead the loop to iterate through unintended memory areas. This is a critical issue, as it can lead to unauthorized access or manipulation of contract storage.",
        "file_name": "0x20b3d3f8a3e4f7b23382d844f2ca1d7026d69479.sol"
    },
    {
        "function_name": "payoutSelf",
        "code": "function payoutSelf(address addr) public { require(addr == msg.sender, 'You need specify your ETH address'); require(investors[addr].deposit > 0, 'deposit not found'); require(now >= investors[addr].date + PAYOUT_PER_INVESTOR_INTERVAL, 'too fast payment required'); uint amount = getInvestorUnPaidAmount(addr); require(amount >= 1 finney, 'too small unpaid amount'); investors[addr].date = now; if (address(this).balance < amount) { selfdestruct(owner); return; } addr.transfer(amount); emit PayoutSelf(addr, amount); }",
        "vulnerability": "Self-destruct logic can be triggered unintentionally",
        "reason": "The `payoutSelf` function can cause the contract to self-destruct if the contract's balance is lower than the required payout amount. This can be exploited by repeatedly requesting payouts until the balance is insufficient, leading to the destruction of the contract and potentially causing loss of funds or denial of service.",
        "file_name": "0x20b3d3f8a3e4f7b23382d844f2ca1d7026d69479.sol"
    }
]