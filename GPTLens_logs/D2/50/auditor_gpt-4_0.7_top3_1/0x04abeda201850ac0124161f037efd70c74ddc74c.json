[
    {
        "function_name": "transfer",
        "code": "function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= IterableMapping.iterate_getValue(balances, msg.sender)); require(_to != address(0)); IterableMapping.insert(balances, msg.sender, IterableMapping.iterate_getValue(balances, msg.sender).sub(_value)); IterableMapping.insert(balances, _to, IterableMapping.iterate_getValue(balances, _to).add(_value)); emit Transfer(msg.sender, _to, _value); return true; }",
        "vulnerability": "Reentrancy",
        "reason": "The transfer function updates balances using an external library call to 'insert' which can potentially be a vector for reentrancy attacks. Since the balance of the sender is updated after the balance of the receiver, a malicious receiver contract could call back into this contract and double-spend. This is because the sender's balance is only reduced after the receiver's balance is increased, potentially allowing the recursive call to execute the transfer again.",
        "file_name": "0x04abeda201850ac0124161f037efd70c74ddc74c.sol"
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= IterableMapping.iterate_getValue(balances, _from)); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); IterableMapping.insert(balances, _from, IterableMapping.iterate_getValue(balances, _from).sub(_value)); IterableMapping.insert(balances, _to, IterableMapping.iterate_getValue(balances, _to).add(_value)); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; }",
        "vulnerability": "Reentrancy",
        "reason": "Similar to the 'transfer' function, 'transferFrom' also updates balances using external library calls and then modifies the allowance. The order of operations allows for a reentrancy attack because if a malicious contract is one of the parties, it could potentially call back into 'transferFrom' during execution. Since allowance is only decreased after the balances are updated, it can lead to issues where the allowance check passes initially but fails to protect against multiple withdrawals.",
        "file_name": "0x04abeda201850ac0124161f037efd70c74ddc74c.sol"
    },
    {
        "function_name": "approve",
        "code": "function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; }",
        "vulnerability": "Race Condition",
        "reason": "The 'approve' function sets the allowance for a spender without considering any previously set allowances. This can result in a race condition known as 'front-running', where a malicious spender can quickly spend the remaining allowance before the sender has a chance to reset it to a lower value. This could result in unexpected spending of tokens because the check and update of the allowance are not atomic.",
        "file_name": "0x04abeda201850ac0124161f037efd70c74ddc74c.sol"
    }
]