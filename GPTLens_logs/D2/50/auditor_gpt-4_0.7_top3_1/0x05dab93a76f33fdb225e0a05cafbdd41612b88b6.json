[
    {
        "function_name": "reveal",
        "code": "function reveal() public inState(State.Reveal) { bytes memory signature = commitment[msg.sender].signature; require(signature.length != 0); bytes32 r; bytes32 s; uint8 v; assembly { r := mload(add(signature,0x20)) s := mload(add(signature,0x40)) v := byte(0, mload(add(signature, 96))) } if (v < 27) v += 27; if(ecrecover(isSolved.msgHash, v, r, s) == msg.sender) { if(winner.timestamp == 0 || commitment[msg.sender].timestamp < winner.timestamp) { winner.winner = msg.sender; winner.timestamp = commitment[msg.sender].timestamp; } } delete commitment[msg.sender]; }",
        "vulnerability": "Missing validation of signature length",
        "reason": "The function only checks if the signature length is not zero but does not validate the length to be exactly what is required (65 bytes for a valid Ethereum signature). This can allow signatures of incorrect lengths to potentially cause unexpected behavior or manipulation of the signature extraction and ecrecover operation.",
        "file_name": "0x05dab93a76f33fdb225e0a05cafbdd41612b88b6.sol"
    },
    {
        "function_name": "reward",
        "code": "function reward() public inState(State.Payout) { if(winner.winner != 0) selfdestruct(winner.winner); else selfdestruct(bipedaljoe); }",
        "vulnerability": "Use of selfdestruct",
        "reason": "The use of selfdestruct can lead to loss of funds or denial of service as it removes the contract from the blockchain. An attacker could potentially manipulate the state (e.g., becoming the winner by exploiting other vulnerabilities) and trigger selfdestruct, making any contract balance sent to an attacker-controlled address.",
        "file_name": "0x05dab93a76f33fdb225e0a05cafbdd41612b88b6.sol"
    },
    {
        "function_name": "authenticate",
        "code": "function authenticate(bytes _publicKey) public inState(State.Commit) { require(commitment[msg.sender].timestamp != 0); bytes memory keyHash = getHash(_publicKey); bytes32 hash1; bytes32 hash2; assembly { hash1 := mload(add(keyHash,0x20)) hash2 := mload(add(keyHash,0x40)) } bytes32 r = proof_of_public_key1 ^ hash1; bytes32 s = proof_of_public_key2 ^ hash2; bytes32 msgHash = keccak256(\"\\x19Ethereum Signed Message:\\n64\", _publicKey); address signer = address(keccak256(_publicKey)); if(ecrecover(msgHash, 27, r, s) == signer || ecrecover(msgHash, 28, r, s) == signer ) { isSolved.timestamp = now; isSolved.publicKey = _publicKey; isSolved.msgHash = msgHash; } }",
        "vulnerability": "Weak cryptographic scheme",
        "reason": "The function uses a simple XOR operation to compute the values of r and s from hashes of the public key and fixed proofs (proof_of_public_key1 and proof_of_public_key2). Predictable or weak cryptographic operations could potentially allow an attacker to reverse-engineer or predict valid public keys that pass authentication checks, leading to unauthorized solving of the challenge.",
        "file_name": "0x05dab93a76f33fdb225e0a05cafbdd41612b88b6.sol"
    }
]