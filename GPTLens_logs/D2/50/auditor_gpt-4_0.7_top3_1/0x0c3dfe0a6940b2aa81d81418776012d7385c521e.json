[
    {
        "function_name": "getLosersOnePercent",
        "code": "function getLosersOnePercent(uint loser) public returns (uint) { require(votingOpen); require(msg.sender == address(ballot)); if(loser==1) { ballot.transfer(philadelphiaBets.div(100)); return philadelphiaBets.div(100); } else if (loser==2) { ballot.transfer(newEnglandBets.div(100)); return newEnglandBets.div(100); } else { return 0; } }",
        "vulnerability": "Reentrancy",
        "reason": "The function 'getLosersOnePercent' is vulnerable to reentrancy attacks because it performs a transfer of funds (using 'ballot.transfer()') based on external calls before updating its state. An attacker could potentially re-enter this function during the transfer, leading to unexpected behavior such as draining funds.",
        "file_name": "0x0c3dfe0a6940b2aa81d81418776012d7385c521e.sol"
    },
    {
        "function_name": "voteResult",
        "code": "function voteResult(uint team) public payable { require(votingStart <= now && votingEnd >= now); require(voted[msg.sender] == false); require(msg.value == 50 finney); require(!closed); if(team == 1) { phiWon += 1; } else if (team == 2) { neWon += 1; } else revert(); voted[msg.sender] = true; votes[msg.sender] = team; totalVoters += 1; stake[msg.sender] = msg.value; }",
        "vulnerability": "Denial of Service",
        "reason": "The function 'voteResult' does not handle the case where 'team' is neither 1 nor 2 except for reverting the transaction. This could be exploited by an attacker to cause a denial of service by repeatedly sending transactions with an invalid 'team' value, causing all transactions to fail after consuming gas.",
        "file_name": "0x0c3dfe0a6940b2aa81d81418776012d7385c521e.sol"
    },
    {
        "function_name": "getWinnings",
        "code": "function getWinnings(address winner, uint donation) public { require(donation<=100); require(withdrawalOpen); require(bets[winner].claimed == false); uint winnings = 0; if (result == 1) winnings = (getPhiladelphiaBets(winner).mul(winningPot)).div(philadelphiaBets); else if (result == 2) winnings = (getNewEnglandBets(winner).mul(winningPot)).div(newEnglandBets); else revert(); wins[winner] = winnings; uint donated = winnings.mul(donation).div(100); bets[winner].claimed = true; winner.transfer(winnings-donated); }",
        "vulnerability": "Integer Overflow/Underflow",
        "reason": "The function 'getWinnings' computes winnings based on the proportion of bets without safeguarding against potential integer overflow/underflow issues. This could lead to incorrect computation of winnings, particularly if the values of 'winningPot', 'philadelphiaBets', or 'newEnglandBets' are manipulated or reach extreme values.",
        "file_name": "0x0c3dfe0a6940b2aa81d81418776012d7385c521e.sol"
    }
]