[
    {
        "function_name": "transferFrom",
        "code": "function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; }",
        "vulnerability": "Missing return value check",
        "reason": "The function does not check the return value of the 'sub' and 'add' calls from the SafeMath library. If the subtraction results in an underflow or the addition results in an overflow, the SafeMath library will revert the transaction. However, the function will continue executing until the revert, potentially leading to inconsistent state or unexpected behavior.",
        "file_name": "0xd6b3d9e44f767f0c178f60d24fb186ba49bc444a.sol"
    },
    {
        "function_name": "buyTicketsFor",
        "code": "function buyTicketsFor(address _beneficiary) public payable { require(_beneficiary != 0x0); require(msg.value >= PRICE); uint256 change = msg.value%PRICE; uint256 numberOfTickets = msg.value.sub(change).div(PRICE); ticket.mint(_beneficiary, numberOfTickets); addParticipant(_beneficiary, numberOfTickets); msg.sender.transfer(change); }",
        "vulnerability": "Denial of service via unbounded loop",
        "reason": "The function 'addParticipant' is called within 'buyTicketsFor', which iterates based on '_numberOfTickets'. If '_numberOfTickets' is extremely large, this can lead to an unbounded loop consuming all the gas provided to the transaction, thus causing it to fail. This can be exploited to prevent legitimate operations on the contract.",
        "file_name": "0xd6b3d9e44f767f0c178f60d24fb186ba49bc444a.sol"
    },
    {
        "function_name": "refundPlayersAfterVeryLongGame",
        "code": "function refundPlayersAfterVeryLongGame() public { require(block.number.sub(gameStartedAtBlock) >= INACTIVITY); require(counter%SIZE != 0); uint256 _size = counter%SIZE; counter -= _size; for (uint8 i = 0; i < _size; i++) { participants[gameIndex][i].transfer(PRICE); } GameRefunded(gameIndex); increaseGame(); }",
        "vulnerability": "Potential for gas limit issues",
        "reason": "This function includes a loop that transfers ether to an arbitrary number of participants. If the number of participants is large, the loop may require more gas than is available in a block, causing the transaction to fail. This could lock funds in the contract indefinitely if the game is not able to progress past a certain point due to gas limitations.",
        "file_name": "0xd6b3d9e44f767f0c178f60d24fb186ba49bc444a.sol"
    }
]