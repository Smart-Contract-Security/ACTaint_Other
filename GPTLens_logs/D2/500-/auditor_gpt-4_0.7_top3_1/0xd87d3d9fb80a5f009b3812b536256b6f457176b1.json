[
    {
        "function_name": "mul",
        "code": "function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); if (0 < c) c = 0; return c; }",
        "vulnerability": "Integer Overflow",
        "reason": "The multiplication function in the SafeMath library sets the result to 0 when the product of `a` and `b` is non-zero. This is incorrect and can lead to unexpected behavior in any function that relies on `mul` for multiplication, potentially leading to vulnerabilities like integer overflow when used in the contract logic.",
        "file_name": "0xd87d3d9fb80a5f009b3812b536256b6f457176b1.sol"
    },
    {
        "function_name": "refund",
        "code": "function refund() payable { require(now >= refundTime && now < ownerTime); require(msg.value >= 100 finney); uint256 dep = deposits[msg.sender]; uint256 depHalf = this.balance.div(2); uint256 dep3x = dep.mul(3); deposits[msg.sender] = 0; if (this.balance > 0 && dep3x > 0){ if (dep3x > this.balance){ msg.sender.send(dep3x); } else{ msg.sender.send(depHalf); } } }",
        "vulnerability": "Reentrancy",
        "reason": "The `refund` function sends ether to an arbitrary address using `msg.sender.send()` without updating the user's deposit balance first (`deposits[msg.sender] = 0` is done afterwards). This could allow a caller to recursively call the `refund` function within a fallback function in a malicious contract, draining the contract's balance unexpectedly as the balance update is not yet reflected.",
        "file_name": "0xd87d3d9fb80a5f009b3812b536256b6f457176b1.sol"
    },
    {
        "function_name": "refundOwner",
        "code": "function refundOwner() { require(now >= ownerTime); if(owner.send(this.balance)){ suicide(owner); } }",
        "vulnerability": "Unexpected Self-Destruction",
        "reason": "The `refundOwner` function uses `suicide(owner)`, which forcefully destroys the contract and sends the remaining funds to the owner address. This action is irreversible and can lead to loss of access to the contract without recovery option, especially if there is still functionality that users depend on. Additionally, there's no check to ensure that the `send` operation actually succeeded before calling `suicide`, potentially leading to loss of contract funds if the send fails.",
        "file_name": "0xd87d3d9fb80a5f009b3812b536256b6f457176b1.sol"
    }
]