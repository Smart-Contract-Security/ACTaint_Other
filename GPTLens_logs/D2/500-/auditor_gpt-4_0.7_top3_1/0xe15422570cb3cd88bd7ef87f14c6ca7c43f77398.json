[
    {
        "function_name": "refund",
        "code": "function refund() private {\n    uint256 weiValue = this.balance;\n    if (weiValue == 0) throw;\n    uint256 weiRefunded;\n    weiRefunded = safeAdd(weiRefunded, weiValue);\n    refund();\n    if (!msg.sender.send(weiValue)) throw;\n}",
        "vulnerability": "Reentrancy",
        "reason": "The 'refund' function recursively calls itself before sending ether to the caller with 'msg.sender.send(weiValue)'. This recursive call can result in a reentrancy attack, where a malicious contract could repeatedly enter the refund function, draining the contract's balance.",
        "file_name": "0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol"
    },
    {
        "function_name": "claim_bounty",
        "code": "function claim_bounty(){\n    if (bought_tokens) return;\n    if (kill_switch) throw;\n    bought_tokens = true;\n    time_bought = now + 1 days;\n    token.proxyPayment.value(this.balance - bounty)(address(this));\n    if(this.balance > ETH_to_end) {\n        msg.sender.transfer(bounty);\n    } else {\n        time_bought = now + 1 days * 9;\n        if(this.balance > ETH_to_end) {\n            msg.sender.transfer(bounty);\n        }\n    }\n}",
        "vulnerability": "Unchecked external call",
        "reason": "The 'proxyPayment' function is called on an external contract 'token' without checking the return value. If the call fails, the contract execution will continue, potentially leading to inconsistent state or logic errors. This unchecked external call can be exploited by causing the external call to fail, influencing the contract's control flow.",
        "file_name": "0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw(){\n    if (!bought_tokens) {\n        uint256 eth_amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        msg.sender.transfer(eth_amount);\n    } else {\n        uint256 ZBR_amount = balances[msg.sender] * ZBR_per_eth;\n        balances[msg.sender] = 0;\n        uint256 fee = 0;\n        if (!checked_in[msg.sender]) {\n            fee = ZBR_amount / 100;\n            if(!token.transfer(developer_address, fee)) throw;\n        }\n        if(!token.transfer(msg.sender, ZBR_amount - fee)) throw;\n    }\n}",
        "vulnerability": "DoS with unexpected revert",
        "reason": "In the 'withdraw' function, if the 'token.transfer' call fails, it will cause the whole transaction to revert due to the 'throw'. This can be used by an attacker to deny service to other legitimate users by making the transfer always fail (e.g., by depleting the token balance or other means), thus preventing withdrawal of funds.",
        "file_name": "0xe15422570cb3cd88bd7ef87f14c6ca7c43f77398.sol"
    }
]