[
    {
        "function_name": "initiateWithFees",
        "code": "function initiateWithFees( bytes32 _swapID, address payable _spender, address payable _broker, uint256 _brokerFee, bytes32 _secretLock, uint256 _timelock, uint256 _value ) public onlyInvalidSwaps(_swapID) payable { require(_value >= _brokerFee, \"fee must be less than value\"); Swap memory swap = Swap({ timelock: _timelock, brokerFee: _brokerFee, value: _value - _brokerFee, funder: msg.sender, spender: _spender, broker: _broker, secretLock: _secretLock, secretKey: 0x0 }); swaps[_swapID] = swap; _swapStates[_swapID] = States.OPEN; emit LogOpen(_swapID, _spender, _secretLock); }",
        "vulnerability": "Reentrancy",
        "reason": "The function 'initiateWithFees' is vulnerable to reentrancy attacks because it modifies the state after calling an external contract (Broker). The state change `_swapStates[_swapID] = States.OPEN;` should occur before the external call to minimize the risk of reentrancy.",
        "file_name": "0x517f5e4e7fda6792b338227d4f6eb34c83c5499d.sol"
    },
    {
        "function_name": "redeem",
        "code": "function redeem(bytes32 _swapID, address payable _receiver, bytes32 _secretKey) public onlyOpenSwaps(_swapID) onlyWithSecretKey(_swapID, _secretKey) onlySpender(_swapID, msg.sender) { require(_receiver != address(0x0), \"invalid receiver\"); swaps[_swapID].secretKey = _secretKey; _swapStates[_swapID] = States.CLOSED; _redeemedAt[_swapID] = now; _brokerFees[swaps[_swapID].broker] += swaps[_swapID].brokerFee; emit LogClose(_swapID, _secretKey); }",
        "vulnerability": "Front-running",
        "reason": "The 'redeem' function is susceptible to front-running because it publicly reveals the secret key in a transaction. Malicious users can watch the transaction pool and use the secret key in their own transactions, potentially redeeming or otherwise interacting with the contract before the original transaction is processed.",
        "file_name": "0x517f5e4e7fda6792b338227d4f6eb34c83c5499d.sol"
    },
    {
        "function_name": "withdrawBrokerFees",
        "code": "function withdrawBrokerFees(uint256 _amount) public { require(_amount <= _brokerFees[msg.sender], \"insufficient withdrawable fees\"); _brokerFees[msg.sender] -= _amount; }",
        "vulnerability": "Denial of Service",
        "reason": "The function 'withdrawBrokerFees' does not perform an actual transfer of funds but only updates internal state. This might lead to a situation where brokers believe they have withdrawn their fees while the actual assets remain within the contract, potentially leading to a denial of service as brokers might refuse further participation believing they are not being paid.",
        "file_name": "0x517f5e4e7fda6792b338227d4f6eb34c83c5499d.sol"
    }
]