[
    {
        "function_name": "fallback function",
        "code": "function() public payable whenNotPaused { require(msg.value >= PRICE_WEI, 'Insufficient Ether'); if (_counter == QMAX) { uint r = DMAX; uint winpos = 0; _blocks.push(block.number); bytes32 _a = blockhash(block.number - 1); for (uint i = 31; i >= 1; i--) { if (uint8(_a[i]) >= 48 && uint8(_a[i]) <= 57) { winpos = 10 * winpos + (uint8(_a[i]) - 48); if (--r == 0) break; } } _positions.push(winpos); uint _reward = (QMAX * PRICE_WEI * 90) / 100; address _winner = _queue[winpos]; _winners.push(_winner); _winner.transfer(_reward); history storage h = _history[_winner]; h.prices[h.size - 1] = _reward; _wincomma.push(0x0); _wincommb.push(0x0); emit NewWinner(_winner, _round, winpos, h.values[h.size - 1], _reward); _collectibles += address(this).balance - _reward; _counter = 0; _round++; } h = _history[msg.sender]; require(h.size == 0 || h.rounds[h.size - 1] != _round, 'Already In Round'); h.size++; h.rounds.push(_round); h.places.push(_counter); h.values.push(msg.value); h.prices.push(0); if (_round == 0) { _queue.push(msg.sender); } else { _queue[_counter] = msg.sender; } emit NewDropIn(msg.sender, _round, _counter, msg.value); _counter++; }",
        "vulnerability": "Use of Predictable RNG",
        "reason": "The method for determining the winner relies on the blockhash of the previous block, which is predictable by miners. They can manipulate the result to become the winners, especially since the value depends on the last byte of the hash, which is easier to influence.",
        "file_name": "0x81b1ff50d5bca9150700e7265f7216e65c8936e6.sol"
    },
    {
        "function_name": "blackList",
        "code": "function blackList(address user) public onlyOwner { history storage h = _history[user]; if (h.size > 0) { h.blacklist = FLAG_BLACKLIST; } }",
        "vulnerability": "Denial of Service",
        "reason": "The blackList function allows the owner to permanently exclude participants from the game by setting their blacklist flag. This can be used arbitrarily against any address, effectively locking their participation without a structured appeal or recovery process, leading to potential loss of funds or denial of service.",
        "file_name": "0x81b1ff50d5bca9150700e7265f7216e65c8936e6.sol"
    },
    {
        "function_name": "fallback function",
        "code": "function() public payable whenNotPaused { require(msg.value >= PRICE_WEI, 'Insufficient Ether'); if (_counter == QMAX) { uint r = DMAX; uint winpos = 0; _blocks.push(block.number); bytes32 _a = blockhash(block.number - 1); for (uint i = 31; i >= 1; i--) { if (uint8(_a[i]) >= 48 && uint8(_a[i]) <= 57) { winpos = 10 * winpos + (uint8(_a[i]) - 48); if (--r == 0) break; } } _positions.push(winpos); uint _reward = (QMAX * PRICE_WEI * 90) / 100; address _winner = _queue[winpos]; _winners.push(_winner); _winner.transfer(_reward); history storage h = _history[_winner]; h.prices[h.size - 1] = _reward; _wincomma.push(0x0); _wincommb.push(0x0); emit NewWinner(_winner, _round, winpos, h.values[h.size - 1], _reward); _collectibles += address(this).balance - _reward; _counter = 0; _round++; } h = _history[msg.sender]; require(h.size == 0 || h.rounds[h.size - 1] != _round, 'Already In Round'); h.size++; h.rounds.push(_round); h.places.push(_counter); h.values.push(msg.value); h.prices.push(0); if (_round == 0) { _queue.push(msg.sender); } else { _queue[_counter] = msg.sender; } emit NewDropIn(msg.sender, _round, _counter, msg.value); _counter++; }",
        "vulnerability": "Reentrancy",
        "reason": "The fallback function sends Ether to an external address (_winner.transfer(_reward)). If _winner is a contract, it can call back into the contract during the transfer, before the _round or _counter variables are updated, potentially allowing it to manipulate the game state or withdraw funds repeatedly.",
        "file_name": "0x81b1ff50d5bca9150700e7265f7216e65c8936e6.sol"
    }
]