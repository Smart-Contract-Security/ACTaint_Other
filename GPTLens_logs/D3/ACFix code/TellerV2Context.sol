pragma solidity >=0.8.0 <0.9.0;
import "./TellerV2Storage.sol";
import "./ERC2771ContextUpgradeable.sol";
abstract contract TellerV2Context is
    ERC2771ContextUpgradeable,
    TellerV2Storage
{
    using EnumerableSet for EnumerableSet.AddressSet;
    event TrustedMarketForwarderSet(
        uint256 indexed marketId,
        address forwarder,
        address sender
    );
    event MarketForwarderApproved(
        uint256 indexed marketId,
        address indexed forwarder,
        address sender
    );
    constructor(address trustedForwarder)
        ERC2771ContextUpgradeable(trustedForwarder)
    {}
    function isTrustedMarketForwarder(
        uint256 _marketId,
        address _trustedMarketForwarder
    ) public view returns (bool) {
        return
            _trustedMarketForwarders[_marketId] == _trustedMarketForwarder ||
            lenderCommitmentForwarder == _trustedMarketForwarder;
    }
    function hasApprovedMarketForwarder(
        uint256 _marketId,
        address _forwarder,
        address _account
    ) public view returns (bool) {
        return
            isTrustedMarketForwarder(_marketId, _forwarder) &&
            _approvedForwarderSenders[_forwarder].contains(_account);
    }
    function setTrustedMarketForwarder(uint256 _marketId, address _forwarder)
        external
    {
        require(
            marketRegistry.getMarketOwner(_marketId) == _msgSender(),
            "Caller must be the market owner"
        );
        _trustedMarketForwarders[_marketId] = _forwarder;
        emit TrustedMarketForwarderSet(_marketId, _forwarder, _msgSender());
    }
    function approveMarketForwarder(uint256 _marketId, address _forwarder)
        external
    {
        require(
            isTrustedMarketForwarder(_marketId, _forwarder),
            "Forwarder must be trusted by the market"
        );
        _approvedForwarderSenders[_forwarder].add(_msgSender());
        emit MarketForwarderApproved(_marketId, _forwarder, _msgSender());
    }
    function _msgSenderForMarket(uint256 _marketId)
        internal
        view
        virtual
        returns (address)
    {
        if (isTrustedMarketForwarder(_marketId, _msgSender())) {
            address sender;
            assembly {
                sender := shr(96, calldataload(sub(calldatasize(), 20)))
            }
            require(
                _approvedForwarderSenders[_msgSender()].contains(sender),
                "Sender must approve market forwarder"
            );
            return sender;
        }
        return _msgSender();
    }
    function _msgDataForMarket(uint256 _marketId)
        internal
        view
        virtual
        returns (bytes calldata)
    {
        if (isTrustedMarketForwarder(_marketId, _msgSender())) {
            return msg.data[:msg.data.length - 20];
        } else {
            return _msgData();
        }
    }
}