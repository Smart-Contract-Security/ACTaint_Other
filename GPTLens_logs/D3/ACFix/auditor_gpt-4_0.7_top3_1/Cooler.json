[
    {
        "function_name": "request",
        "code": "function request (uint256 amount, uint256 interest, uint256 loanToCollateral, uint256 duration) external returns (uint256 reqID) { reqID = requests.length; factory.newEvent(reqID, CoolerFactory.Events.Request); requests.push(Request(amount, interest, loanToCollateral, duration, true)); collateral.transferFrom(msg.sender, address(this), collateralFor(amount, loanToCollateral)); }",
        "vulnerability": "Unchecked external call",
        "reason": "The function 'request' makes an external call with 'collateral.transferFrom' to transfer collateral tokens from the requester to the contract. However, it does not check the return value of this call, which can fail silently (returning false as per ERC20 standards) leading to a state where the request is registered without the actual transfer of collateral, potentially causing inconsistencies in the state of the contract and allowing requests to be made without proper collateral.",
        "file_name": "Cooler.sol"
    },
    {
        "function_name": "roll",
        "code": "function roll (uint256 loanID) external { Loan storage loan = loans[loanID]; Request memory req = loan.request; if (block.timestamp > loan.expiry) revert Default(); if (!loan.rollable) revert NotRollable(); uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral; uint256 newDebt = interestFor(loan.amount, req.interest, req.duration); loan.amount += newDebt; loan.expiry += req.duration; loan.collateral += newCollateral; collateral.transferFrom(msg.sender, address(this), newCollateral); }",
        "vulnerability": "Reentrancy",
        "reason": "The 'roll' function allows the renewal or rollover of a loan by adjusting the loan's terms and updating the collateral. However, the function makes an external call with 'collateral.transferFrom' at the end of the function, after state changes have been made (loan.amount, loan.expiry, loan.collateral are updated). This can potentially allow reentrancy attacks where an attacker could call back into the contract before the first execution completes, leading to unexpected behavior or exploits.",
        "file_name": "Cooler.sol"
    },
    {
        "function_name": "defaulted",
        "code": "function defaulted (uint256 loanID) external returns (uint256) { Loan memory loan = loans[loanID]; delete loans[loanID]; if (block.timestamp <= loan.expiry) revert NoDefault(); collateral.transfer(loan.lender, loan.collateral); return loan.collateral; }",
        "vulnerability": "Use of delete on loan struct",
        "reason": "The 'defaulted' function deletes a loan from the storage array using the 'delete' keyword, which resets the struct to its default values. This operation does not shift the array elements to fill the gap, resulting in invalid loan indices and an unsorted array. This can lead to confusion or wrong access to loans in future operations and might cause issues with array index management, potentially leading to unauthorized access or manipulation of loan data.",
        "file_name": "Cooler.sol"
    }
]