[
    {
        "function_name": "_transfer",
        "code": "function _transfer( address sender, address recipient, uint256 amount ) internal { require(sender != address(0), \"ERC20: transfer from the zero address\"); require(!isBlackListed[sender] && !isBlackListed[recipient],\"sender or recipient is blacklisted\"); _beforeTokenTransfer(sender, recipient, amount); uint totalHolders_ = totalHolders; (bool vs,uint senderBalance) = _updateBalance(sender); (bool vr,uint recipientBalance) = _updateBalance(recipient); if(vs && senderBalance == amount){ totalHolders_ = totalHolders_ - 1; } if(vr && recipientBalance == 0){ totalHolders_ = totalHolders_ + 1; } require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); uint recipientAmount = amount; if(sender != address(0) && recipient != address(0) && !isWhiteList[sender] && !isWhiteList[recipient]){ FeeAmounts memory feeAmounts = _calcTransferFees(amount); if(feeAmounts.feeAmount > 0){ recipientAmount = recipientAmount - feeAmounts.feeAmount; address feeTo_ = feeTo; (,uint feeToCapital) = _updateBalance(feeTo_); if(feeToCapital == 0){ totalHolders_ += 1; } _balances[feeTo_] = feeToCapital.add(feeAmounts.feeAmount); emit Transfer(sender, feeTo_, feeAmounts.feeAmount); } if(feeAmounts.parentAmount + feeAmounts.grandpaAmount > 0){ address parent = rlink.parentOf(recipient); if(parent != address(0)){ if(feeAmounts.parentAmount > 0){ recipientAmount = recipientAmount - feeAmounts.parentAmount; (bool v,uint pb) = _updateBalance(parent); if(v && pb == 0){ totalHolders_ += 1; } _balances[parent] = pb.add(feeAmounts.parentAmount); emit Transfer(sender, parent, feeAmounts.parentAmount); emit ParentsRewardsPaid(recipient,parent,feeAmounts.parentAmount,true); } if(feeAmounts.grandpaAmount > 0){ address grandpa = rlink.parentOf(parent); if(grandpa != address(0)){ recipientAmount = recipientAmount - feeAmounts.grandpaAmount; (bool v,uint gb) = _updateBalance(grandpa); if(v && gb==0){ totalHolders_ += 1; } _balances[grandpa] = gb.add(feeAmounts.grandpaAmount); emit Transfer(sender, grandpa, feeAmounts.grandpaAmount); emit ParentsRewardsPaid(recipient,grandpa,feeAmounts.grandpaAmount,false); }else{ feeAmounts.burnAmount = feeAmounts.burnAmount + feeAmounts.grandpaAmount; } } }else{ feeAmounts.burnAmount = feeAmounts.burnAmount + feeAmounts.parentAmount + feeAmounts.grandpaAmount; } } if(feeAmounts.holdersAmount > 0){ if(totalHolders_ > 0){ recipientAmount = recipientAmount - feeAmounts.holdersAmount; rewardPerHolderStored = rewardPerHolderStored + feeAmounts.holdersAmount / totalHolders_; emit DividendsPaid(feeAmounts.holdersAmount,totalHolders_); } } if(feeAmounts.burnAmount > 0){ recipientAmount = recipientAmount - feeAmounts.burnAmount; _balances[_blackHole] = _balances[_blackHole] + feeAmounts.burnAmount; emit Transfer(sender, _blackHole, feeAmounts.burnAmount); } } totalHolders = totalHolders_; _balances[sender] = senderBalance.sub(amount); _balances[recipient] = recipientBalance.add(recipientAmount); emit Transfer(sender, recipient, recipientAmount); _afterTokenTransfer(sender, recipient, amount); }",
        "vulnerability": "Reentrancy",
        "reason": "In the '_transfer' function, there is no mechanism preventing reentrancy attacks which could allow an attacker to call the function recursively before the first invocation completes. This can lead to unexpected behaviour like draining funds or corrupting the state of the contract.",
        "file_name": "LPC.sol"
    },
    {
        "function_name": "setFeeRates",
        "code": "function setFeeRates(uint burnRate,uint feeRate,uint holdersRate,uint parentRate,uint grandpaRate,uint burnStopSupply) public onlyOwner { require(burnRate.add(feeRate).add(holdersRate).add(parentRate).add(grandpaRate) <= 1e9,\"sum of rates can not greater than 1e9\"); require(burnStopSupply <= _totalSupply,\"burn stop supply can not greater than total supply\"); feeRates = RateConfig({ burnRate: SafeCast.toUint32(burnRate), feeRate: SafeCast.toUint32(feeRate), holdersRate: SafeCast.toUint32(holdersRate), parentRate: SafeCast.toUint32(parentRate), grandpaRate: SafeCast.toUint32(grandpaRate), burnStopSupply: SafeCast.toUint96(burnStopSupply) }); }",
        "vulnerability": "Potential Integer Overflow",
        "reason": "The function 'setFeeRates' could potentially lead to an integer overflow if the summation of all rates exceeds the maximum value for the feeRates structure. This can lead to unexpected behaviour such as incorrect fee rates being set, potentially enabling theft or loss of funds.",
        "file_name": "LPC.sol"
    },
    {
        "function_name": "transferFrom",
        "code": "function transferFrom( address sender, address recipient, uint256 amount ) public override returns (bool) { _transfer(sender, recipient, amount); uint256 currentAllowance = _allowances[sender][_msgSender()]; require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); unchecked { _approve(sender, _msgSender(), currentAllowance - amount); } return true; }",
        "vulnerability": "Unchecked External Call",
        "reason": "In the 'transferFrom' function, the '_approve' function call is made in an unchecked block, which can potentially lead to underflows. This could be exploited by an attacker to allow for unauthorized spending of tokens.",
        "file_name": "LPC.sol"
    }
]