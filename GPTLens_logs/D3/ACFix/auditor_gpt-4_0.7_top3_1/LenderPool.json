[
    {
        "function_name": "withdrawInterest",
        "code": "function withdrawInterest(uint256 _id, address _lender) external nonReentrant { _withdrawInterest(_id, _lender); }",
        "vulnerability": "Potential reentrancy attack",
        "reason": "Although the function is marked nonReentrant, the actual withdrawal of funds and state changes are handled by the internal function '_withdrawInterest'. If the internal function is not properly secured, it could potentially lead to reentrancy attacks if it calls external contracts without proper reentrancy protection. This could be exploited by a malicious contract calling 'withdrawInterest', and then re-entering it through callbacks from those external calls.",
        "file_name": "LenderPool.sol"
    },
    {
        "function_name": "_withdrawInterest",
        "code": "function _withdrawInterest(uint256 _id, address _lender) internal { address _strategy = pooledCLConstants[_id].borrowAssetStrategy; address _borrowAsset = pooledCLConstants[_id].borrowAsset; (uint256 _interestToWithdraw, uint256 _interestSharesToWithdraw) = _calculateInterestToWithdraw( _id, _lender, _strategy, _borrowAsset ); pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw); if (_interestToWithdraw != 0) { SAVINGS_ACCOUNT.withdraw(_borrowAsset, _strategy, _lender, _interestToWithdraw, false); } emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw); }",
        "vulnerability": "Unchecked return values",
        "reason": "The function does not check the return values of the external calls, specifically 'SAVINGS_ACCOUNT.withdraw'. If the external call fails or behaves unexpectedly (returns false or reverts), the state of 'pooledCLVariables[_id].sharesHeld' would still be updated, which could lead to inconsistencies in state, allowing for potential exploits where users could withdraw funds without proper accounting.",
        "file_name": "LenderPool.sol"
    },
    {
        "function_name": "_withdrawInterest",
        "code": "function _withdrawInterest(uint256 _id, address _lender) internal { address _strategy = pooledCLConstants[_id].borrowAssetStrategy; address _borrowAsset = pooledCLConstants[_id].borrowAsset; (uint256 _interestToWithdraw, uint256 _interestSharesToWithdraw) = _calculateInterestToWithdraw( _id, _lender, _strategy, _borrowAsset ); pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw); if (_interestToWithdraw != 0) { SAVINGS_ACCOUNT.withdraw(_borrowAsset, _strategy, _lender, _interestToWithdraw, false); } emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw); }",
        "vulnerability": "Race condition",
        "reason": "The function updates the state of 'pooledCLVariables[_id].sharesHeld' before actually performing the withdrawal. This can lead to a race condition where two concurrent calls might read the same initial state and both attempt to withdraw funds based on that state, possibly resulting in double withdrawal or other unexpected behaviors.",
        "file_name": "LenderPool.sol"
    }
]