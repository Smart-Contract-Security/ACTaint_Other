[
    {
        "function_name": "setPerpRiskParams",
        "code": "function setPerpRiskParams( Types.State storage state, address perp, Types.RiskParams calldata param ) external { if (state.perpRiskParams[perp].isRegistered && !param.isRegistered) { for (uint256 i; i < state.registeredPerp.length;) { if (state.registeredPerp[i] == perp) { state.registeredPerp[i] = state.registeredPerp[ state.registeredPerp.length - 1 ]; state.registeredPerp.pop(); } unchecked { ++i; } } } if (!state.perpRiskParams[perp].isRegistered && param.isRegistered) { state.registeredPerp.push(perp); } require( param.liquidationPriceOff + param.insuranceFeeRate <= param.liquidationThreshold, Errors.INVALID_RISK_PARAM ); state.perpRiskParams[perp] = param; emit UpdatePerpRiskParams(perp, param); }",
        "vulnerability": "Unchecked Array Removal",
        "reason": "In the function 'setPerpRiskParams', when removing a perpetual from 'registeredPerp' array, the code does not break the loop after finding and removing the perpetual. This can lead to unnecessary iterations, and potential out-of-gas errors if the array is large, which can be used by an attacker in a denial of service (DoS) attack by repeatedly registering and unregistering a perpetual to make the array grow.",
        "file_name": "Operation.sol"
    },
    {
        "function_name": "updateFundingRate",
        "code": "function updateFundingRate( address[] calldata perpList, int256[] calldata rateList ) external { require( perpList.length == rateList.length, Errors.ARRAY_LENGTH_NOT_SAME ); for (uint256 i = 0; i < perpList.length;) { int256 oldRate = IPerpetual(perpList[i]).getFundingRate(); IPerpetual(perpList[i]).updateFundingRate(rateList[i]); emit UpdateFundingRate(perpList[i], oldRate, rateList[i]); unchecked { ++i; } } }",
        "vulnerability": "Unchecked External Calls",
        "reason": "The function 'updateFundingRate' calls external contract methods 'getFundingRate' and 'updateFundingRate' without checking whether these calls succeed. If the call to 'updateFundingRate' fails but does not revert (e.g., the external contract uses a 'try/catch' without reverting), the funding rate in the external contract would not be updated, but the event 'UpdateFundingRate' would still be emitted, leading to inconsistent state between the actual funding rate and the emitted logs.",
        "file_name": "Operation.sol"
    },
    {
        "function_name": "setSecondaryAsset",
        "code": "function setSecondaryAsset( Types.State storage state, address _secondaryAsset ) external { require( state.secondaryAsset == address(0), Errors.SECONDARY_ASSET_ALREADY_EXIST ); require( IDecimalERC20(_secondaryAsset).decimals() == IDecimalERC20(state.primaryAsset).decimals(), Errors.SECONDARY_ASSET_DECIMAL_WRONG ); state.secondaryAsset = _secondaryAsset; emit SetSecondaryAsset(_secondaryAsset); }",
        "vulnerability": "Re-entrancy",
        "reason": "This function 'setSecondaryAsset' calls an external contract 'IDecimalERC20(_secondaryAsset).decimals()' to get decimals of the secondary asset. If the external contract is malicious, it could potentially make re-entrant calls back into the smart contract during the decimals() invocation. Even though there are checks before state updates, the re-entrancy could still potentially interact in unexpected ways with other parts of the contract not shown in the snippet.",
        "file_name": "Operation.sol"
    }
]