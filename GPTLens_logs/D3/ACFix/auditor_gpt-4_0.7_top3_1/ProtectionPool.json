[
    {
        "function_name": "accruePremiumAndExpireProtections",
        "code": "function accruePremiumAndExpireProtections(address[] memory _lendingPools) external override {\n    if (_lendingPools.length == 0) {\n        _lendingPools = poolInfo.referenceLendingPools.getLendingPools();\n    }\n    uint256 _totalPremiumAccrued;\n    uint256 _totalProtectionRemoved;\n    uint256 length = _lendingPools.length;\n    for (uint256 _lendingPoolIndex; _lendingPoolIndex < length; ) {\n        address _lendingPool = _lendingPools[_lendingPoolIndex];\n        LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[ _lendingPool ];\n        uint256 _latestPaymentTimestamp = poolInfo .referenceLendingPools .getLatestPaymentTimestamp(_lendingPool);\n        uint256 _lastPremiumAccrualTimestamp = lendingPoolDetail .lastPremiumAccrualTimestamp;\n        ( uint256 _accruedPremiumForLendingPool, uint256 _totalProtectionRemovedForLendingPool ) = _accruePremiumAndExpireProtections( lendingPoolDetail, _lastPremiumAccrualTimestamp, _latestPaymentTimestamp );\n        _totalPremiumAccrued += _accruedPremiumForLendingPool;\n        _totalProtectionRemoved += _totalProtectionRemovedForLendingPool;\n        if (_accruedPremiumForLendingPool > 0) {\n            lendingPoolDetail.lastPremiumAccrualTimestamp = _latestPaymentTimestamp;\n            emit PremiumAccrued(_lendingPool, _latestPaymentTimestamp);\n        }\n        unchecked { ++_lendingPoolIndex; }\n    }\n    if (_totalPremiumAccrued > 0) {\n        totalPremiumAccrued += _totalPremiumAccrued;\n        totalSTokenUnderlying += _totalPremiumAccrued;\n    }\n    if (_totalProtectionRemoved > 0) {\n        totalProtection -= _totalProtectionRemoved;\n    }\n}",
        "vulnerability": "Unchecked External Calls",
        "reason": "The function 'accruePremiumAndExpireProtections' makes external calls to get lending pools and latest payment timestamps, which are unchecked. If these external calls fail or are manipulated to return incorrect values, it could lead to incorrect updating of internal state variables, affecting premium accruals and protection tracking.",
        "file_name": "ProtectionPool.sol"
    },
    {
        "function_name": "lockCapital",
        "code": "function lockCapital(address _lendingPoolAddress) external payable override onlyDefaultStateManager whenNotPaused returns (uint256 _lockedAmount, uint256 _snapshotId) {\n    _snapshotId = _snapshot();\n    LendingPoolDetail storage lendingPoolDetail = lendingPoolDetails[ _lendingPoolAddress ];\n    EnumerableSetUpgradeable.UintSet storage activeProtectionIndexes = lendingPoolDetail .activeProtectionIndexes;\n    uint256 _length = activeProtectionIndexes.length();\n    for (uint256 i; i < _length; ) {\n        uint256 _protectionIndex = activeProtectionIndexes.at(i);\n        ProtectionInfo storage protectionInfo = protectionInfos[_protectionIndex];\n        uint256 _remainingPrincipal = poolInfo .referenceLendingPools .calculateRemainingPrincipal( _lendingPoolAddress, protectionInfo.buyer, protectionInfo.purchaseParams.nftLpTokenId );\n        uint256 _protectionAmount = protectionInfo .purchaseParams .protectionAmount;\n        uint256 _lockedAmountPerProtection = _protectionAmount < _remainingPrincipal ? _protectionAmount : _remainingPrincipal;\n        _lockedAmount += _lockedAmountPerProtection;\n        unchecked { ++i; }\n    }\n    unchecked { if (totalSTokenUnderlying < _lockedAmount) {\n        _lockedAmount = totalSTokenUnderlying;\n        totalSTokenUnderlying = 0;\n    } else {\n        totalSTokenUnderlying -= _lockedAmount;\n    } }\n}",
        "vulnerability": "Unchecked External Call Return Value",
        "reason": "The function 'lockCapital' relies on the return value of 'calculateRemainingPrincipal' from an external call which is not validated. If this external function call returns incorrect values due to a bug or malicious attack on the referenced contract, it could lead to incorrect locking of capital amounts, potentially locking more or less capital than intended.",
        "file_name": "ProtectionPool.sol"
    },
    {
        "function_name": "withdraw",
        "code": "function withdraw(uint256 _sTokenWithdrawalAmount, address _receiver) external override whenPoolIsOpen whenNotPaused nonReentrant {\n    uint256 _currentCycleIndex = poolCycleManager.getCurrentCycleIndex( address(this) );\n    WithdrawalCycleDetail storage withdrawalCycle = withdrawalCycleDetails[ _currentCycleIndex ];\n    uint256 _sTokenRequested = withdrawalCycle.withdrawalRequests[msg.sender];\n    if (_sTokenRequested == 0) {\n        revert NoWithdrawalRequested(msg.sender, _currentCycleIndex);\n    }\n    if (_sTokenWithdrawalAmount > _sTokenRequested) {\n        revert WithdrawalHigherThanRequested(msg.sender, _sTokenRequested);\n    }\n    uint256 _underlyingAmountToTransfer = convertToUnderlying( _sTokenWithdrawalAmount );\n    _burn(msg.sender, _sTokenWithdrawalAmount);\n    totalSTokenUnderlying -= _underlyingAmountToTransfer;\n    withdrawalCycle.withdrawalRequests[msg.sender] -= _sTokenWithdrawalAmount;\n    withdrawalCycle.totalSTokenRequested -= _sTokenWithdrawalAmount;\n    poolInfo.underlyingToken.safeTransfer( _receiver, _underlyingAmountToTransfer );\n    emit WithdrawalMade(msg.sender, _sTokenWithdrawalAmount, _receiver);\n}",
        "vulnerability": "Reentrancy on Untrusted External Calls",
        "reason": "The function 'withdraw' performs state changes after calling an untrusted external contract to transfer tokens. If the external contract is malicious or buggy, it could lead to reentrancy attacks where the state changes in 'withdraw' can be exploited to withdraw more funds than intended or disrupt the contract state.",
        "file_name": "ProtectionPool.sol"
    }
]