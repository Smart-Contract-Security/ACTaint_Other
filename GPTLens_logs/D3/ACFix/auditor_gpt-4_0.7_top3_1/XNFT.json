[
    {
        "function_name": "pledgeInternal",
        "code": "function pledgeInternal(address _collection, uint256 _tokenId, uint256 _nftType) internal whenNotPaused(1) returns(uint256){ require(_nftType == 721 || _nftType == 1155, \"don't support this nft type\"); if(_collection != address(punks)){ transferNftInternal(msg.sender, address(this), _collection, _tokenId, _nftType); }else{ _depositPunk(_tokenId); _collection = address(wrappedPunks); } require(collectionWhiteList[_collection].isCollectionWhiteList, \"collection not insist\"); counter = counter.add(1); uint256 _orderId = counter; Order storage _order = allOrders[_orderId]; _order.collection = _collection; _order.tokenId = _tokenId; _order.nftType = _nftType; _order.pledger = msg.sender; ordersMap[msg.sender].push(counter); emit Pledge(_collection, _tokenId, _orderId, msg.sender); return _orderId; }",
        "vulnerability": "Reentrancy",
        "reason": "The function 'pledgeInternal' is called by other functions that are marked as nonReentrant, but 'pledgeInternal' itself transfers control to external contracts (via 'transferNftInternal', 'punks.buyPunk', 'punks.transferPunk', 'wrappedPunks.mint') before all its internal state updates are finished. This can lead to reentrancy attacks where the state may be tampered with during the execution of these external calls.",
        "file_name": "XNFT.sol"
    },
    {
        "function_name": "auction",
        "code": "function auction(uint256 orderId, uint256 amount) payable external nonReentrant whenNotPaused(3){ require(isOrderLiquidated(orderId), \"this order is not a liquidation order\"); LiquidatedOrder storage liquidatedOrder = allLiquidatedOrder[orderId]; require(liquidatedOrder.auctionWinner == address(0), \"the order has been withdrawn\"); require(!liquidatedOrder.isPledgeRedeem, \"redeemed by the pledgor\"); Order storage _order = allOrders[orderId]; if(IXToken(liquidatedOrder.xToken).underlying() == ADDRESS_ETH){ amount = msg.value; } uint256 price; if(liquidatedOrder.auctionAccount == address(0)){ price = liquidatedOrder.liquidatedPrice; }else{ price = liquidatedOrder.auctionPrice; } bool isPledger = auctionAllowed(_order.pledger, msg.sender, _order.collection, liquidatedOrder.liquidatedStartTime, price, amount); if(isPledger){ uint256 fine = price.mul(pledgerFineRate).div(1e18); uint256 _amount = liquidatedOrder.liquidatedPrice.add(fine); doTransferIn(liquidatedOrder.xToken, payable(msg.sender), _amount); uint256 rewardFirst = fine.mul(rewardFirstRate).div(1e18); if(liquidatedOrder.auctionAccount != address(0)){ doTransferOut(liquidatedOrder.xToken, payable(liquidatedOrder.liquidator), rewardFirst); uint256 rewardLast = fine.mul(rewardLastRate).div(1e18); doTransferOut(liquidatedOrder.xToken, payable(liquidatedOrder.auctionAccount), (rewardLast + liquidatedOrder.auctionPrice)); addUpIncomeMap[liquidatedOrder.xToken] = addUpIncomeMap[liquidatedOrder.xToken] + (fine - rewardFirst - rewardLast); }else{ doTransferOut(liquidatedOrder.xToken, payable(liquidatedOrder.liquidator), (liquidatedOrder.liquidatedPrice + rewardFirst)); addUpIncomeMap[liquidatedOrder.xToken] = addUpIncomeMap[liquidatedOrder.xToken] + (fine - rewardFirst); } transferNftInternal(address(this), msg.sender, _order.collection, _order.tokenId, _order.nftType); _order.isWithdraw = true; liquidatedOrder.isPledgeRedeem = true; liquidatedOrder.auctionWinner = msg.sender; liquidatedOrder.auctionAccount = msg.sender; liquidatedOrder.auctionPrice = _amount; emit AuctionNFT(orderId, liquidatedOrder.xToken, msg.sender, amount, true); emit WithDraw(_order.collection, _order.tokenId, orderId, _order.pledger, msg.sender); }else{ doTransferIn(liquidatedOrder.xToken, payable(msg.sender), amount); if(liquidatedOrder.auctionAccount == address(0)){ doTransferOut(liquidatedOrder.xToken, payable(liquidatedOrder.liquidator), liquidatedOrder.liquidatedPrice); }else{ doTransferOut(liquidatedOrder.xToken, payable(liquidatedOrder.auctionAccount), liquidatedOrder.auctionPrice); } liquidatedOrder.auctionAccount = msg.sender; liquidatedOrder.auctionPrice = amount; emit AuctionNFT(orderId, liquidatedOrder.xToken, msg.sender, amount, false); } }",
        "vulnerability": "Incorrect ETH handling",
        "reason": "The function 'auction' may incorrectly handle ETH amounts. It uses 'msg.value' for the auction amount if the underlying token is ETH, but it does not consider scenarios where 'msg.value' is greater than the intended bid amount, potentially leading to unintended financial transfers.",
        "file_name": "XNFT.sol"
    },
    {
        "function_name": "withdrawNFT",
        "code": "function withdrawNFT(uint256 orderId) external nonReentrant whenNotPaused(2){ LiquidatedOrder storage liquidatedOrder = allLiquidatedOrder[orderId]; Order storage _order = allOrders[orderId]; if(isOrderLiquidated(orderId)){ require(liquidatedOrder.auctionWinner == address(0), \"the order has been withdrawn\"); require(!allLiquidatedOrder[orderId].isPledgeRedeem, \"redeemed by the pledgor\"); CollectionNFT memory collectionNFT = collectionWhiteList[_order.collection]; uint256 auctionDuration; if(collectionNFT.auctionDuration != 0){ auctionDuration = collectionNFT.auctionDuration; }else{ auctionDuration = auctionDurationOverAll; } require(block.timestamp > liquidatedOrder.liquidatedStartTime.add(auctionDuration), \"the auction is not yet closed\"); require(msg.sender == liquidatedOrder.auctionAccount || (liquidatedOrder.auctionAccount == address(0) && msg.sender == liquidatedOrder.liquidator), \"you can't extract NFT\"); transferNftInternal(address(this), msg.sender, _order.collection, _order.tokenId, _order.nftType); if(msg.sender == liquidatedOrder.auctionAccount && liquidatedOrder.auctionPrice != 0){ uint256 profit = liquidatedOrder.auctionPrice.sub(liquidatedOrder.liquidatedPrice); uint256 compensatePledgerAmount = profit.mul(compensatePledgerRate).div(1e18); doTransferOut(liquidatedOrder.xToken, payable(_order.pledger), compensatePledgerAmount); uint256 liquidatorAmount = profit.mul(rewardFirstRate).div(1e18); doTransferOut(liquidatedOrder.xToken, payable(liquidatedOrder.liquidator), liquidatorAmount); addUpIncomeMap[liquidatedOrder.xToken] = addUpIncomeMap[liquidatedOrder.xToken] + (profit - compensatePledgerAmount - liquidatorAmount); } liquidatedOrder.auctionWinner = msg.sender; }else{ require(!_order.isWithdraw, \"the order has been drawn\"); require(_order.pledger != address(0) && msg.sender == _order.pledger, \"withdraw auth failed\"); uint256 borrowBalance = controller.getOrderBorrowBalanceCurrent(orderId); require(borrowBalance == 0, \"order has debt\"); transferNftInternal(address(this), _order.pledger, _order.collection, _order.tokenId, _order.nftType); } _order.isWithdraw = true; emit WithDraw(_order.collection, _order.tokenId, orderId, _order.pledger, msg.sender); }",
        "vulnerability": "Time Manipulation",
        "reason": "The 'withdrawNFT' function relies on 'block.timestamp' for checking if an auction duration has passed, which can be manipulated by miners or influenced by the ordering of transactions within a block. This could potentially allow someone to withdraw an NFT earlier or later than intended.",
        "file_name": "XNFT.sol"
    }
]